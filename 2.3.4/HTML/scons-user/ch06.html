<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 6. Dependencies</title><link rel="stylesheet" type="text/css" href="scons.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="SCons 2.3.4"><link rel="up" href="index.html" title="SCons 2.3.4"><link rel="prev" href="ch05s05.html" title="5.5. GetBuildPath: Getting the Path From a Node or String"><link rel="next" href="ch06s02.html" title="6.2. Older Functions for Deciding When an Input File Has Changed"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 6. Dependencies</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s05.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch06s02.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter 6. Dependencies"><div class="titlepage"><div><div><h2 class="title"><a name="chap-depends"></a>Chapter 6. Dependencies</h2></div></div></div><p>

  So far we've seen how <span class="application">SCons</span> handles one-time builds.
  But one of the main functions of a build tool like <span class="application">SCons</span>
  is to rebuild only what is necessary
  when source files change--or, put another way,
  <span class="application">SCons</span> should <span class="emphasis"><em>not</em></span>
  waste time rebuilding things that don't need to be rebuilt.
  You can see this at work simply by re-invoking <span class="application">SCons</span>
  after building our simple <code class="filename">hello</code> example:

  </p><pre class="screen">% <strong class="userinput"><code>scons -Q</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
% <strong class="userinput"><code>scons -Q</code></strong>
scons: `.' is up to date.
</pre><p>

  The second time it is executed,
  <span class="application">SCons</span> realizes that the <code class="filename">hello</code> program
  is up-to-date with respect to the current <code class="filename">hello.c</code> source file,
  and avoids rebuilding it.
  You can see this more clearly by naming
  the <code class="filename">hello</code> program explicitly on the command line:

  </p><pre class="screen">% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
% <strong class="userinput"><code>scons -Q hello</code></strong>
scons: `hello' is up to date.
</pre><p>

  Note that <span class="application">SCons</span> reports <code class="literal">"...is up to date"</code>
  only for target files named explicitly on the command line,
  to avoid cluttering the output.

  </p><div class="section" title="6.1. Deciding When an Input File Has Changed: the Decider Function"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp4437544"></a>6.1. Deciding When an Input File Has Changed:  the <code class="function">Decider</code> Function</h2></div></div></div><p>

    Another aspect of avoiding unnecessary rebuilds
    is the fundamental build tool behavior
    of <span class="emphasis"><em>rebuilding</em></span>
    things when an input file changes,
    so that the built software is up to date.
    By default,
    <span class="application">SCons</span> keeps track of this through an
    MD5 <code class="literal">signature</code>, or checksum, of the contents of each file,
    although you can easily configure
    <span class="application">SCons</span> to use the
    modification times (or time stamps)
    instead.
    You can even specify your own Python function
    for deciding if an input file has changed.

    </p><div class="section" title="6.1.1. Using MD5 Signatures to Decide if a File Has Changed"><div class="titlepage"><div><div><h3 class="title"><a name="idp4439712"></a>6.1.1. Using MD5 Signatures to Decide if a File Has Changed</h3></div></div></div><p>

      By default,
      <span class="application">SCons</span> keeps track of whether a file has changed
      based on an MD5 checksum of the file's contents,
      not the file's modification time.
      This means that you may be surprised by the
      default <span class="application">SCons</span> behavior if you are used to the
      <span class="application">Make</span> convention of forcing
      a rebuild by updating the file's modification time
      (using the <span class="application">touch</span> command, for example):

      </p><pre class="screen">% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
% <strong class="userinput"><code>touch hello.c</code></strong>
% <strong class="userinput"><code>scons -Q hello</code></strong>
scons: `hello' is up to date.
</pre><p>

      Even though the file's modification time has changed,
      <span class="application">SCons</span> realizes that the contents of the
      <code class="filename">hello.c</code> file have <span class="emphasis"><em>not</em></span> changed,
      and therefore that the <code class="filename">hello</code> program
      need not be rebuilt.
      This avoids unnecessary rebuilds when,
      for example, someone rewrites the
      contents of a file without making a change.
      But if the contents of the file really do change,
      then <span class="application">SCons</span> detects the change
      and rebuilds the program as required:

      </p><pre class="screen">% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
%     [CHANGE THE CONTENTS OF hello.c]
% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
</pre><p>

      Note that you can, if you wish,
      specify this default behavior
      (MD5 signatures) explicitly
      using the <code class="function">Decider</code> function as follows:

      </p><pre class="programlisting">
Program('hello.c')
Decider('MD5')
      </pre><p>

      You can also use the string <code class="literal">'content'</code>
      as a synonym for <code class="literal">'MD5'</code>
      when calling the <code class="function">Decider</code> function.

      </p><div class="section" title="6.1.1.1. Ramifications of Using MD5 Signatures"><div class="titlepage"><div><div><h4 class="title"><a name="idp4447360"></a>6.1.1.1. Ramifications of Using MD5 Signatures</h4></div></div></div><p>

        Using MD5 signatures to decide if an input file has changed
        has one surprising benefit:
        if a source file has been changed
        in such a way that the contents of the
        rebuilt target file(s)
        will be exactly the same as the last time
        the file was built,
        then any "downstream" target files
        that depend on the rebuilt-but-not-changed target
        file actually need not be rebuilt.

        </p><p>

        So if, for example,
        a user were to only change a comment in a <code class="filename">hello.c</code> file,
        then the rebuilt <code class="filename">hello.o</code> file
        would be exactly the same as the one previously built
        (assuming the compiler doesn't put any build-specific
        information in the object file).
        <span class="application">SCons</span> would then realize that it would not
        need to rebuild the <code class="filename">hello</code> program as follows:

        </p><pre class="screen">% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
%   [CHANGE A COMMENT IN hello.c]
% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
scons: `hello' is up to date.
</pre><p>

        In essence, <span class="application">SCons</span>
        "short-circuits" any dependent builds
        when it realizes that a target file
        has been rebuilt to exactly the same file as the last build.
        This does take some extra processing time
        to read the contents of the target (<code class="filename">hello.o</code>) file,
        but often saves time when the rebuild that was avoided
        would have been time-consuming and expensive.

        </p></div></div><div class="section" title="6.1.2. Using Time Stamps to Decide If a File Has Changed"><div class="titlepage"><div><div><h3 class="title"><a name="idp4452104"></a>6.1.2. Using Time Stamps to Decide If a File Has Changed</h3></div></div></div><p>

      If you prefer, you can
      configure <span class="application">SCons</span> to use the modification time
      of a file, not the file contents,
      when deciding if a target needs to be rebuilt.
      <span class="application">SCons</span> gives you two ways to use time stamps
      to decide if an input file has changed
      since the last time a target has been built.

      </p><p>

      The most familiar way to use time stamps
      is the way <span class="application">Make</span> does:
      that is, have <span class="application">SCons</span> decide
      that a target must be rebuilt
      if a source file's modification time is
      <span class="emphasis"><em>newer</em></span>
      than the target file.
      To do this, call the <code class="function">Decider</code>
      function as follows:

      </p><pre class="programlisting">
Object('hello.c')
Decider('timestamp-newer')
        </pre><p>

      This makes <span class="application">SCons</span> act like <span class="application">Make</span>
      when a file's modification time is updated
      (using the <span class="application">touch</span> command, for example):

      </p><pre class="screen">% <strong class="userinput"><code>scons -Q hello.o</code></strong>
cc -o hello.o -c hello.c
% <strong class="userinput"><code>touch hello.c</code></strong>
% <strong class="userinput"><code>scons -Q hello.o</code></strong>
cc -o hello.o -c hello.c
</pre><p>

      And, in fact, because this behavior is the same
      as the behavior of <span class="application">Make</span>,
      you can also use the string <code class="literal">'make'</code>
      as a synonym for <code class="literal">'timestamp-newer'</code>
      when calling the <code class="function">Decider</code> function:

      </p><pre class="programlisting">
Object('hello.c')
Decider('make')
      </pre><p>

      One drawback to using times stamps exactly like <span class="application">Make</span>
      is that if an input file's modification time suddenly
      becomes <span class="emphasis"><em>older</em></span> than a target file,
      the target file will not be rebuilt.
      This can happen if an old copy of a source file is restored
      from a backup archive, for example.
      The contents of the restored file will likely be different
      than they were the last time a dependent target was built,
      but the target won't be rebuilt
      because the modification time of the source file
      is not newer than the target.

      </p><p>

      Because <span class="application">SCons</span> actually stores information
      about the source files' time stamps whenever a target is built,
      it can handle this situation by checking for
      an exact match of the source file time stamp,
      instead of just whether or not the source file
      is newer than the target file.
      To do this, specify the argument
      <code class="literal">'timestamp-match'</code>
      when calling the <code class="function">Decider</code> function:

      </p><pre class="programlisting">
Object('hello.c')
Decider('timestamp-match')
        </pre><p>

      When configured this way,
      <span class="application">SCons</span> will rebuild a target whenever
      a source file's modification time has changed.
      So if we use the <code class="literal">touch -t</code>
      option to change the modification time of
      <code class="filename">hello.c</code> to an old date (January 1, 1989),
      <span class="application">SCons</span> will still rebuild the target file:

      </p><pre class="screen">% <strong class="userinput"><code>scons -Q hello.o</code></strong>
cc -o hello.o -c hello.c
% <strong class="userinput"><code>touch -t 198901010000 hello.c</code></strong>
% <strong class="userinput"><code>scons -Q hello.o</code></strong>
cc -o hello.o -c hello.c
</pre><p>

      In general, the only reason to prefer
      <code class="literal">timestamp-newer</code>
      instead of
      <code class="literal">timestamp-match</code>,
      would be if you have some specific reason
      to require this <span class="application">Make</span>-like behavior of 
      not rebuilding a target when an otherwise-modified
      source file is older.

      </p></div><div class="section" title="6.1.3. Deciding If a File Has Changed Using Both MD Signatures and Time Stamps"><div class="titlepage"><div><div><h3 class="title"><a name="idp4465008"></a>6.1.3. Deciding If a File Has Changed Using Both MD Signatures and Time Stamps</h3></div></div></div><p>

      As a performance enhancement,
      <span class="application">SCons</span> provides a way to use
      MD5 checksums of file contents
      but to read those contents
      only when the file's timestamp has changed.
      To do this, call the <code class="function">Decider</code>
      function with <code class="literal">'MD5-timestamp'</code>
      argument as follows:

      </p><pre class="programlisting">
Program('hello.c')
Decider('MD5-timestamp')
        </pre><p>

      So configured, <span class="application">SCons</span> will still behave like
      it does when using <code class="literal">Decider('MD5')</code>:

      </p><pre class="screen">
% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
% <strong class="userinput"><code>touch hello.c</code></strong>
% <strong class="userinput"><code>scons -Q hello</code></strong>
scons: `hello' is up to date.
% <strong class="userinput"><code>edit hello.c</code></strong>
    [CHANGE THE CONTENTS OF hello.c]
% <strong class="userinput"><code>scons -Q hello</code></strong>
cc -o hello.o -c hello.c
cc -o hello hello.o
      </pre><p>

      However, the second call to <span class="application">SCons</span> in the above output,
      when the build is up-to-date,
      will have been performed by simply looking at the
      modification time of the <code class="filename">hello.c</code> file,
      not by opening it and performing
      an MD5 checksum calcuation on its contents.
      This can significantly speed up many up-to-date builds.

      </p><p>

      The only drawback to using
      <code class="literal">Decider('MD5-timestamp')</code>
      is that <span class="application">SCons</span> will <span class="emphasis"><em>not</em></span>
      rebuild a target file if a source file was modified
      within one second of the last time <span class="application">SCons</span> built the file.
      While most developers are programming,
      this isn't a problem in practice,
      since it's unlikely that someone will have built
      and then thought quickly enough to make a substantive
      change to a source file within one second.
      Certain build scripts or
      continuous integration tools may, however,
      rely on the ability to apply changes to files
      automatically and then rebuild as quickly as possible,
      in which case use of
      <code class="literal">Decider('MD5-timestamp')</code>
      may not be appropriate.

      </p></div><div class="section" title="6.1.4. Writing Your Own Custom Decider Function"><div class="titlepage"><div><div><h3 class="title"><a name="idp4472744"></a>6.1.4. Writing Your Own Custom <code class="function">Decider</code> Function</h3></div></div></div><p>

      The different string values that we've passed to
      the <code class="function">Decider</code> function are essentially used by <span class="application">SCons</span>
      to pick one of several specific internal functions
      that implement various ways of deciding if a dependency
      (usually a source file)
      has changed since a target file has been built.
      As it turns out,
      you can also supply your own function
      to decide if a dependency has changed.

      </p><p>

      For example, suppose we have an input file
      that contains a lot of data,
      in some specific regular format,
      that is used to rebuild a lot of different target files,
      but each target file really only depends on
      one particular section of the input file.
      We'd like to have each target file depend on
      only its section of the input file.
      However, since the input file may contain a lot of data,
      we want to open the input file only if its timestamp has changed.
      This could be done with a custom
      <code class="function">Decider</code> function that might look something like this:

      </p><pre class="programlisting">
Program('hello.c')
def decide_if_changed(dependency, target, prev_ni):
    if self.get_timestamp() != prev_ni.timestamp:
        dep = str(dependency)
        tgt = str(target)
        if specific_part_of_file_has_changed(dep, tgt):
            return True
    return False
Decider(decide_if_changed)
        </pre><p>

      Note that in the function definition,
      the <code class="varname">dependency</code>
      (input file) is the first argument,
      and then the <code class="varname">target</code>.
      Both of these are passed to the functions as
      SCons <code class="classname">Node</code> objects,
      which we convert to strings using the Python
      <code class="function">str()</code>.

      </p><p>

      The third argument, <code class="varname">prev_ni</code>,
      is an object that holds the
      signature or timestamp information
      that was recorded about the dependency
      the last time the target was built.
      A <code class="varname">prev_ni</code> object can hold
      different information,
      depending on the type of thing that the
      <code class="varname">dependency</code> argument represents.
      For normal files,
      the <code class="varname">prev_ni</code> object
      has the following attributes:

      </p><div class="variablelist"><dl><dt><span class="term">.csig</span></dt><dd><p>
        The <span class="emphasis"><em>content signature</em></span>,
        or MD5 checksum, of the contents of the
        <code class="varname">dependency</code>
        file the list time the <code class="varname">target</code> was built.
        </p></dd><dt><span class="term">.size</span></dt><dd><p>
        The size in bytes of the <code class="varname">dependency</code>
        file the list time the target was built.
        </p></dd><dt><span class="term">.timestamp</span></dt><dd><p>
        The modification time of the <code class="varname">dependency</code>
        file the list time the <code class="varname">target</code> was built.
        </p></dd></dl></div><p>

      Note that ignoring some of the arguments
      in your custom <code class="function">Decider</code> function
      is a perfectly normal thing to do,
      if they don't impact the way you want to
      decide if the dependency file has changed.

      </p><p>

      Another thing to look out for is the fact that the three
      attributes above may not be present at the time of the first run.
      Without any prior build, no targets have been created and no
      <code class="filename">.sconsign</code> DB file exists yet.
      So, you should always check whether the
      <code class="varname">prev_ni</code> attribute in question is available.

      </p><p>

      We finally present a small example for a
      <code class="varname">csig</code>-based decider function. Note how the
      signature information for the <code class="varname">dependency</code> file
      has to get initialized via <code class="function">get_csig</code>
      during each function call (this is mandatory!).

      </p><pre class="programlisting">
env = Environment()

def config_file_decider(dependency, target, prev_ni):
    import os.path

    # We always have to init the .csig value...
    dep_csig = dependency.get_csig()
    # .csig may not exist, because no target was built yet...
    if 'csig' not in dir(prev_ni):
        return True
    # Target file may not exist yet
    if not os.path.exists(str(target.abspath)):
        return True
    if dep_csig != prev_ni.csig:
        # Some change on source file =&gt; update installed one
        return True
    return False

def update_file():
    f = open("test.txt","a")
    f.write("some line\n")
    f.close()

update_file()

# Activate our own decider function
env.Decider(config_file_decider)

env.Install("install","test.txt")
      </pre></div><div class="section" title="6.1.5. Mixing Different Ways of Deciding If a File Has Changed"><div class="titlepage"><div><div><h3 class="title"><a name="idp4486784"></a>6.1.5. Mixing Different Ways of Deciding If a File Has Changed</h3></div></div></div><p>

      The previous examples have all demonstrated calling
      the global <code class="function">Decider</code> function
      to configure all dependency decisions that <span class="application">SCons</span> makes.
      Sometimes, however, you want to be able to configure
      different decision-making for different targets.
      When that's necessary, you can use the
      <code class="function">env.Decider</code>
      method to affect only the configuration
      decisions for targets built with a
      specific construction environment.

      </p><p>

      For example, if we arbitrarily want to build
      one program using MD5 checkums
      and another using file modification times
      from the same source
      we might configure it this way:

      </p><pre class="programlisting">
env1 = Environment(CPPPATH = ['.'])
env2 = env1.Clone()
env2.Decider('timestamp-match')
env1.Program('prog-MD5', 'program1.c')
env2.Program('prog-timestamp', 'program2.c')
        </pre><p>

      If both of the programs include the same
      <code class="filename">inc.h</code> file,
      then updating the modification time of
      <code class="filename">inc.h</code>
      (using the <span class="application">touch</span> command)
      will cause only <code class="filename">prog-timestamp</code>
      to be rebuilt:

      </p><pre class="screen">% <strong class="userinput"><code>scons -Q</code></strong>
cc -o program1.o -c -I. program1.c
cc -o prog-MD5 program1.o
cc -o program2.o -c -I. program2.c
cc -o prog-timestamp program2.o
% <strong class="userinput"><code>touch inc.h</code></strong>
% <strong class="userinput"><code>scons -Q</code></strong>
cc -o program2.o -c -I. program2.c
cc -o prog-timestamp program2.o
</pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s05.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch06s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.5. <code class="function">GetBuildPath</code>: Getting the Path From a <code class="classname">Node</code> or String </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6.2. Older Functions for Deciding When an Input File Has Changed</td></tr></table></div></body></html>
