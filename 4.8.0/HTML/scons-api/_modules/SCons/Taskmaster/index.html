

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SCons.Taskmaster &#8212; SCons 4.8.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/SCons/Taskmaster';</script>
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search/"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../">
  
  
  
  
  
  
    <p class="title logo__title">SCons 4.8.0 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../SCons/">SCons package</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Node/">SCons.Node package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Platform/">SCons.Platform package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Scanner/">SCons.Scanner package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Script/">SCons.Script package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Taskmaster/">SCons.Taskmaster package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Tool/">SCons.Tool package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Util/">SCons.Util package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.Variables/">SCons.Variables package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../SCons.compat/">SCons.compat package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.compat/">SCons.compat package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Node/">SCons.Node package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Platform/">SCons.Platform package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Scanner/">SCons.Scanner package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Script/">SCons.Script package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Taskmaster/">SCons.Taskmaster package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Tool/">SCons.Tool package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Util/">SCons.Util package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../SCons.Variables/">SCons.Variables package</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for SCons.Taskmaster</h1><div class="highlight"><pre>
<span></span><span class="c1"># MIT License</span>
<span class="c1">#</span>
<span class="c1"># Copyright The SCons Foundation</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="c1"># a copy of this software and associated documentation files (the</span>
<span class="c1"># &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="c1"># without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="c1"># distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="c1"># permit persons to whom the Software is furnished to do so, subject to</span>
<span class="c1"># the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included</span>
<span class="c1"># in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY</span>
<span class="c1"># KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="c1"># NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="c1"># LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="c1"># OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="c1"># WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;Generic Taskmaster module for the SCons build engine.</span>

<span class="sd">This module contains the primary interface(s) between a wrapping user</span>
<span class="sd">interface and the SCons build engine.  There are two key classes here:</span>

<span class="sd">Taskmaster</span>
<span class="sd">    This is the main engine for walking the dependency graph and</span>
<span class="sd">    calling things to decide what does or doesn&#39;t need to be built.</span>

<span class="sd">Task</span>
<span class="sd">    This is the base class for allowing a wrapping interface to</span>
<span class="sd">    decide what does or doesn&#39;t actually need to be done.  The</span>
<span class="sd">    intention is for a wrapping interface to subclass this as</span>
<span class="sd">    appropriate for different types of behavior it may need.</span>

<span class="sd">    The canonical example is the SCons native Python interface,</span>
<span class="sd">    which has Task subclasses that handle its specific behavior,</span>
<span class="sd">    like printing &quot;&#39;foo&#39; is up to date&quot; when a top-level target</span>
<span class="sd">    doesn&#39;t need to be built, and handling the -c option by removing</span>
<span class="sd">    targets as its &quot;build&quot; action.  There is also a separate subclass</span>
<span class="sd">    for suppressing this output when the -q option is used.</span>

<span class="sd">    The Taskmaster instantiates a Task object for each (set of)</span>
<span class="sd">    target(s) that it decides need to be evaluated and/or built.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">SCons.Errors</span>
<span class="kn">import</span> <span class="nn">SCons.Node</span>
<span class="kn">import</span> <span class="nn">SCons.Warnings</span>
<span class="kn">from</span> <span class="nn">SCons.Util</span> <span class="kn">import</span> <span class="n">DispatchingFormatter</span>

<span class="n">StateString</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">StateString</span>
<span class="n">NODE_NO_STATE</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">no_state</span>
<span class="n">NODE_PENDING</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">pending</span>
<span class="n">NODE_EXECUTING</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">executing</span>
<span class="n">NODE_UP_TO_DATE</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">up_to_date</span>
<span class="n">NODE_EXECUTED</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">executed</span>
<span class="n">NODE_FAILED</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">failed</span>
<span class="n">print_prepare</span> <span class="o">=</span> <span class="kc">False</span>               <span class="c1"># set by option --debug=prepare</span>

<span class="c1"># A subsystem for recording stats about how different Nodes are handled by</span>
<span class="c1"># the main Taskmaster loop.  There&#39;s no external control here (no need for</span>
<span class="c1"># a --debug= option); enable it by changing the value of CollectStats.</span>

<span class="n">CollectStats</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="Stats"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Stats">[docs]</a><span class="k">class</span> <span class="nc">Stats</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple class for holding statistics about the disposition of a</span>
<span class="sd">    Node by the Taskmaster.  If we&#39;re collecting statistics, each Node</span>
<span class="sd">    processed by the Taskmaster gets one of these attached, in which case</span>
<span class="sd">    the Taskmaster records its decision each time it processes the Node.</span>
<span class="sd">    (Ideally, that&#39;s just once per Node.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a Taskmaster.Stats object, initializing all</span>
<span class="sd">        appropriate counters to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">considered</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">already_handled</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_failed</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">not_built</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">side_effects</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span>  <span class="o">=</span> <span class="mi">0</span></div>


<span class="n">StatsNodes</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%(considered)3d</span><span class="s2"> &quot;</span>\
      <span class="s2">&quot;</span><span class="si">%(already_handled)3d</span><span class="s2"> &quot;</span> \
      <span class="s2">&quot;</span><span class="si">%(problem)3d</span><span class="s2"> &quot;</span> \
      <span class="s2">&quot;</span><span class="si">%(child_failed)3d</span><span class="s2"> &quot;</span> \
      <span class="s2">&quot;</span><span class="si">%(not_built)3d</span><span class="s2"> &quot;</span> \
      <span class="s2">&quot;</span><span class="si">%(side_effects)3d</span><span class="s2"> &quot;</span> \
      <span class="s2">&quot;</span><span class="si">%(build)3d</span><span class="s2"> &quot;</span>


<div class="viewcode-block" id="dump_stats"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.dump_stats">[docs]</a><span class="k">def</span> <span class="nf">dump_stats</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">StatsNodes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">((</span><span class="n">fmt</span> <span class="o">%</span> <span class="n">n</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></div>


<div class="viewcode-block" id="Task"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task">[docs]</a><span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; SCons build engine abstract task class.</span>

<span class="sd">    This controls the interaction of the actual building of node</span>
<span class="sd">    and the rest of the engine.</span>

<span class="sd">    This is expected to handle all of the normally-customizable</span>
<span class="sd">    aspects of controlling a build, so any given application</span>
<span class="sd">    *should* be able to do what it wants by sub-classing this</span>
<span class="sd">    class and overriding methods as appropriate.  If an application</span>
<span class="sd">    needs to customize something by sub-classing Taskmaster (or</span>
<span class="sd">    some other build engine class), we should first try to migrate</span>
<span class="sd">    that functionality into this class.</span>

<span class="sd">    Note that it&#39;s generally a good idea for sub-classes to call</span>
<span class="sd">    these methods explicitly to update state, etc., rather than</span>
<span class="sd">    roll their own interaction with Taskmaster from scratch.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOGGER</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tm</span> <span class="o">=</span> <span class="n">tm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="n">targets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">top</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc_clear</span><span class="p">()</span>

<div class="viewcode-block" id="Task.trace_message"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.trace_message">[docs]</a>    <span class="k">def</span> <span class="nf">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This grabs the name of the function which calls trace_message()</span>
        <span class="n">method_name</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="o">+</span><span class="s2">&quot;():&quot;</span>
        <span class="n">Task</span><span class="o">.</span><span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%-15s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Task.display"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hook to allow the calling interface to display a message.</span>

<span class="sd">        This hook gets called as part of preparing a task for execution</span>
<span class="sd">        (that is, a Node to be built).  As part of figuring out what Node</span>
<span class="sd">        should be built next, the actual target list may be altered,</span>
<span class="sd">        along with a message describing the alteration.  The calling</span>
<span class="sd">        interface can subclass Task and provide a concrete implementation</span>
<span class="sd">        of this method to see those messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Task.prepare"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.prepare">[docs]</a>    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called just before the task is executed.</span>

<span class="sd">        This is mainly intended to give the target Nodes a chance to</span>
<span class="sd">        unlink underlying files and make all necessary directories before</span>
<span class="sd">        the Action is actually called to build the targets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">print_prepare</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Now that it&#39;s the appropriate time, give the TaskMaster a</span>
        <span class="c1"># chance to raise any exceptions it encountered while preparing</span>
        <span class="c1"># this task.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception_raise</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">message</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Let the targets take care of any necessary preparations.</span>
        <span class="c1"># This includes verifying that all of the necessary sources</span>
        <span class="c1"># and dependencies exist, removing the target file(s), etc.</span>
        <span class="c1">#</span>
        <span class="c1"># As of April 2008, the get_executor().prepare() method makes</span>
        <span class="c1"># sure that all of the aggregate sources necessary to build this</span>
        <span class="c1"># Task&#39;s target(s) exist in one up-front check.  The individual</span>
        <span class="c1"># target t.prepare() methods check that each target&#39;s explicit</span>
        <span class="c1"># or implicit dependencies exists, and also initialize the</span>
        <span class="c1"># .sconsign info.</span>
        <span class="n">executor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_executor</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">executor</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">executor</span><span class="o">.</span><span class="n">get_action_targets</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">print_prepare</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preparing target </span><span class="si">%s</span><span class="s2">...&quot;</span><span class="o">%</span><span class="n">t</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;...with side-effect </span><span class="si">%s</span><span class="s2">...&quot;</span><span class="o">%</span><span class="n">s</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_prepare</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;...Preparing side-effect </span><span class="si">%s</span><span class="s2">...&quot;</span><span class="o">%</span><span class="n">s</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span></div>

<div class="viewcode-block" id="Task.get_target"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.get_target">[docs]</a>    <span class="k">def</span> <span class="nf">get_target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetch the target being built or updated by this task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span></div>

<div class="viewcode-block" id="Task.needs_execute"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.needs_execute">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">needs_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Task.execute"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to execute the task.</span>

<span class="sd">        This method is called from multiple threads in a parallel build,</span>
<span class="sd">        so only do thread safe stuff here.  Do thread unsafe stuff in</span>
<span class="sd">        prepare(), executed() or failed().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">cached_targets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">retrieve_from_cache</span><span class="p">():</span>
                    <span class="k">break</span>
                <span class="n">cached_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cached_targets</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                <span class="c1"># Remove targets before building. It&#39;s possible that we</span>
                <span class="c1"># partially retrieved targets from the cache, leaving</span>
                <span class="c1"># them in read-only mode. That might cause the command</span>
                <span class="c1"># to fail.</span>
                <span class="c1">#</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cached_targets</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">get_internal_path</span><span class="p">())</span>
                    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">SCons</span><span class="o">.</span><span class="n">Warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">SCons</span><span class="o">.</span><span class="n">Warnings</span><span class="o">.</span><span class="n">CacheCleanupErrorWarning</span><span class="p">,</span>
                            <span class="s2">&quot;Failed copying all target files from cache, Error while attempting to remove file </span><span class="si">%s</span><span class="s2"> retrieved from cache: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">get_internal_path</span><span class="p">(),</span> <span class="n">e</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">push_to_cache</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cached_targets</span><span class="p">:</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">cached</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">SystemExit</span><span class="p">:</span>
            <span class="n">exc_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">ExplicitExit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exc_value</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">UserError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">BuildError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">buildError</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">convert_to_BuildError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">buildError</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">buildError</span><span class="o">.</span><span class="n">exc_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">buildError</span></div>

<div class="viewcode-block" id="Task.executed_without_callbacks"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.executed_without_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">executed_without_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when the task has been successfully executed</span>
<span class="sd">        and the Taskmaster instance doesn&#39;t want to call</span>
<span class="sd">        the Node&#39;s callback methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span> <span class="o">==</span> <span class="n">NODE_EXECUTING</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">side_effect</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span><span class="p">:</span>
                    <span class="n">side_effect</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_NO_STATE</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_EXECUTED</span><span class="p">)</span></div>

<div class="viewcode-block" id="Task.executed_with_callbacks"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.executed_with_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">executed_with_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when the task has been successfully executed and</span>
<span class="sd">        the Taskmaster instance wants to call the Node&#39;s callback</span>
<span class="sd">        methods.</span>

<span class="sd">        This may have been a do-nothing operation (to preserve build</span>
<span class="sd">        order), so we must check the node&#39;s state before deciding whether</span>
<span class="sd">        it was &quot;built&quot;, in which case we call the appropriate Node method.</span>
<span class="sd">        In any event, we always call &quot;visited()&quot;, which will handle any</span>
<span class="sd">        post-visit actions that must take place regardless of whether</span>
<span class="sd">        or not the target was an actual built target or a source Node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">print_prepare</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span> <span class="o">==</span> <span class="n">NODE_EXECUTING</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">side_effect</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span><span class="p">:</span>
                    <span class="n">side_effect</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_NO_STATE</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_EXECUTED</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">built</span><span class="p">()</span>
                <span class="n">t</span><span class="o">.</span><span class="n">visited</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">print_prepare</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;options&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">debug_includes</span><span class="p">)):</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">release_target_info</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">visited</span><span class="p">()</span></div>

    <span class="n">executed</span> <span class="o">=</span> <span class="n">executed_with_callbacks</span>

<div class="viewcode-block" id="Task.failed"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.failed">[docs]</a>    <span class="k">def</span> <span class="nf">failed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Default action when a task fails:  stop the build.</span>

<span class="sd">        Note: Although this function is normally invoked on nodes in</span>
<span class="sd">        the executing state, it might also be invoked on up-to-date</span>
<span class="sd">        nodes when using Configure().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail_stop</span><span class="p">()</span></div>

<div class="viewcode-block" id="Task.fail_stop"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.fail_stop">[docs]</a>    <span class="k">def</span> <span class="nf">fail_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Explicit stop-the-build failure.</span>

<span class="sd">        This sets failure status on the target nodes and all of</span>
<span class="sd">        their dependent parent nodes.</span>

<span class="sd">        Note: Although this function is normally invoked on nodes in</span>
<span class="sd">        the executing state, it might also be invoked on up-to-date</span>
<span class="sd">        nodes when using Configure().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Invoke will_not_build() to clean-up the pending children</span>
        <span class="c1"># list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">will_not_build</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_FAILED</span><span class="p">))</span>

        <span class="c1"># Tell the taskmaster to not start any new tasks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

        <span class="c1"># We&#39;re stopping because of a build failure, but give the</span>
        <span class="c1"># calling Task class a chance to postprocess() the top-level</span>
        <span class="c1"># target under which the build failure occurred.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">current_top</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Task.fail_continue"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.fail_continue">[docs]</a>    <span class="k">def</span> <span class="nf">fail_continue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Explicit continue-the-build failure.</span>

<span class="sd">        This sets failure status on the target nodes and all of</span>
<span class="sd">        their dependent parent nodes.</span>

<span class="sd">        Note: Although this function is normally invoked on nodes in</span>
<span class="sd">        the executing state, it might also be invoked on up-to-date</span>
<span class="sd">        nodes when using Configure().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">will_not_build</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_FAILED</span><span class="p">))</span></div>

<div class="viewcode-block" id="Task.make_ready_all"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.make_ready_all">[docs]</a>    <span class="k">def</span> <span class="nf">make_ready_all</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Marks all targets in a task ready for execution.</span>

<span class="sd">        This is used when the interface needs every target Node to be</span>
<span class="sd">        visited--the canonical example being the &quot;scons -c&quot; option.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_of_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">disambiguate</span><span class="p">()</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_EXECUTING</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span><span class="p">:</span>
                <span class="c1"># add disambiguate here to mirror the call on targets above</span>
                <span class="n">s</span><span class="o">.</span><span class="n">disambiguate</span><span class="p">()</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_EXECUTING</span><span class="p">)</span></div>

<div class="viewcode-block" id="Task.make_ready_current"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.make_ready_current">[docs]</a>    <span class="k">def</span> <span class="nf">make_ready_current</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Marks all targets in a task ready for execution if any target</span>
<span class="sd">        is not current.</span>

<span class="sd">        This is the default behavior for building only what&#39;s necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">print_prepare</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">T</span><span class="o">.</span><span class="n">log_handler</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># Prefix message with new line. This is a hack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_of_date</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">needs_executing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">disambiguate</span><span class="p">()</span><span class="o">.</span><span class="n">make_ready</span><span class="p">()</span>
                <span class="n">is_up_to_date</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">has_builder</span><span class="p">()</span> <span class="ow">or</span> \
                                <span class="p">(</span><span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">always_build</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">is_up_to_date</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">BuildError</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">errstr</span><span class="o">=</span><span class="n">e</span><span class="o">.</span><span class="n">strerror</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">e</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_up_to_date</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_of_date</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">needs_executing</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">needs_executing</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_EXECUTING</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span><span class="p">:</span>
                    <span class="c1"># add disambiguate here to mirror the call on targets in first loop above</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">disambiguate</span><span class="p">()</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_EXECUTING</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                <span class="c1"># We must invoke visited() to ensure that the node</span>
                <span class="c1"># information has been computed before allowing the</span>
                <span class="c1"># parent nodes to execute. (That could occur in a</span>
                <span class="c1"># parallel build...)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">visited</span><span class="p">()</span>
                <span class="n">t</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_UP_TO_DATE</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">print_prepare</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;options&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">debug_includes</span><span class="p">)):</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">release_target_info</span><span class="p">()</span></div>

    <span class="n">make_ready</span> <span class="o">=</span> <span class="n">make_ready_current</span>

<div class="viewcode-block" id="Task.postprocess"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.postprocess">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-processes a task after it&#39;s been executed.</span>

<span class="sd">        This examines all the targets just built (or not, we don&#39;t care</span>
<span class="sd">        if the build was successful, or even if there was no build</span>
<span class="sd">        because everything was up-to-date) to see if they have any</span>
<span class="sd">        waiting parent Nodes, or Nodes waiting on a common side effect,</span>
<span class="sd">        that can be put back on the candidates list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># We may have built multiple targets, some of which may have</span>
        <span class="c1"># common parents waiting for this build.  Count up how many</span>
        <span class="c1"># targets each parent was waiting for so we can subtract the</span>
        <span class="c1"># values later, and so we *don&#39;t* put waiting side-effect Nodes</span>
        <span class="c1"># back on the candidates list if the Node is also a waiting</span>
        <span class="c1"># parent.</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>

        <span class="n">pending_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">pending_children</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="c1"># A node can only be in the pending_children set if it has</span>
            <span class="c1"># some waiting_parents.</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;removing&#39;</span><span class="p">)</span>
                <span class="n">pending_children</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">parents</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">t</span><span class="o">.</span><span class="n">waiting_parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">side_effects</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span> <span class="o">==</span> <span class="n">NODE_EXECUTING</span><span class="p">:</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_NO_STATE</span><span class="p">)</span>

                    <span class="c1"># The side-effects may have been transferred to</span>
                    <span class="c1"># NODE_NO_STATE by executed_with{,out}_callbacks, but was</span>
                    <span class="c1"># not taken out of the waiting parents/pending children</span>
                    <span class="c1"># data structures. Check for that now.</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span> <span class="o">==</span> <span class="n">NODE_NO_STATE</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">:</span>
                        <span class="n">pending_children</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">:</span>
                            <span class="n">parents</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">parents</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">waiting_parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">waiting_s_e</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">subtract</span> <span class="ow">in</span> <span class="n">parents</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">-</span> <span class="n">subtract</span>
            <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace_message</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;adjusted parent ref count&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tm</span><span class="o">.</span><span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">postprocess</span><span class="p">()</span></div>

    <span class="c1"># Exception handling subsystem.</span>
    <span class="c1">#</span>
    <span class="c1"># Exceptions that occur while walking the DAG or examining Nodes</span>
    <span class="c1"># must be raised, but must be raised at an appropriate time and in</span>
    <span class="c1"># a controlled manner so we can, if necessary, recover gracefully,</span>
    <span class="c1"># possibly write out signature information for Nodes we&#39;ve updated,</span>
    <span class="c1"># etc.  This is done by having the Taskmaster tell us about the</span>
    <span class="c1"># exception, and letting</span>

<div class="viewcode-block" id="Task.exc_info"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.exc_info">[docs]</a>    <span class="k">def</span> <span class="nf">exc_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns info about a recorded exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exception</span></div>

<div class="viewcode-block" id="Task.exc_clear"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.exc_clear">[docs]</a>    <span class="k">def</span> <span class="nf">exc_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears any recorded exception.</span>

<span class="sd">        This also changes the &quot;exception_raise&quot; attribute to point</span>
<span class="sd">        to the appropriate do-nothing method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception_raise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_exception_to_raise</span></div>

<div class="viewcode-block" id="Task.exception_set"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task.exception_set">[docs]</a>    <span class="k">def</span> <span class="nf">exception_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Records an exception to be raised at the appropriate time.</span>

<span class="sd">        This also changes the &quot;exception_raise&quot; attribute to point</span>
<span class="sd">        to the method that will, in fact</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exception</span><span class="p">:</span>
            <span class="n">exception</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception</span> <span class="o">=</span> <span class="n">exception</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception_raise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exception_raise</span></div>

<div class="viewcode-block" id="Task._no_exception_to_raise"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task._no_exception_to_raise">[docs]</a>    <span class="k">def</span> <span class="nf">_no_exception_to_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Task._exception_raise"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Task._exception_raise">[docs]</a>    <span class="k">def</span> <span class="nf">_exception_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raises a pending exception that was recorded while getting a</span>
<span class="sd">        Task ready for execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[:]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_traceback</span> <span class="o">=</span> <span class="n">exc</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span> <span class="o">=</span> <span class="n">exc</span>  <span class="c1"># pylint: disable=unbalanced-tuple-unpacking</span>
            <span class="n">exc_traceback</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># raise exc_type(exc_value).with_traceback(exc_traceback)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span> <span class="c1">#hasattr(exc_value, &#39;with_traceback&#39;):</span>
            <span class="c1"># If exc_value is an exception, then just reraise</span>
            <span class="k">raise</span> <span class="n">exc_value</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">exc_traceback</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else we&#39;ll create an exception using the value and raise that</span>
            <span class="k">raise</span> <span class="n">exc_type</span><span class="p">(</span><span class="n">exc_value</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">exc_traceback</span><span class="p">)</span></div></div>


        <span class="c1"># raise e.__class__, e.__class__(e), sys.exc_info()[2]</span>
        <span class="c1">#     exec(&quot;raise exc_type(exc_value).with_traceback(exc_traceback)&quot;)</span>



<div class="viewcode-block" id="AlwaysTask"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.AlwaysTask">[docs]</a><span class="k">class</span> <span class="nc">AlwaysTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
<div class="viewcode-block" id="AlwaysTask.needs_execute"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.AlwaysTask.needs_execute">[docs]</a>    <span class="k">def</span> <span class="nf">needs_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always returns True (indicating this Task should always</span>
<span class="sd">        be executed).</span>

<span class="sd">        Subclasses that need this behavior (as opposed to the default</span>
<span class="sd">        of only executing Nodes that are out of date w.r.t. their</span>
<span class="sd">        dependencies) can use this as follows:</span>

<span class="sd">            class MyTaskSubclass(SCons.Taskmaster.Task):</span>
<span class="sd">                needs_execute = SCons.Taskmaster.AlwaysTask.needs_execute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div></div>

<div class="viewcode-block" id="OutOfDateTask"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.OutOfDateTask">[docs]</a><span class="k">class</span> <span class="nc">OutOfDateTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
<div class="viewcode-block" id="OutOfDateTask.needs_execute"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.OutOfDateTask.needs_execute">[docs]</a>    <span class="k">def</span> <span class="nf">needs_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True (indicating this Task should be executed) if this</span>
<span class="sd">        Task&#39;s target state indicates it needs executing, which has</span>
<span class="sd">        already been determined by an earlier up-to-date check.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span> <span class="o">==</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">executing</span></div></div>


<div class="viewcode-block" id="find_cycle"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.find_cycle">[docs]</a><span class="k">def</span> <span class="nf">find_cycle</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">stack</span>
        <span class="k">if</span> <span class="n">find_cycle</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">stack</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Taskmaster"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster">[docs]</a><span class="k">class</span> <span class="nc">Taskmaster</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Taskmaster for walking the dependency DAG.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[],</span> <span class="n">tasker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_top</span> <span class="o">=</span> <span class="n">targets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_targets_left</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_targets_left</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">tasker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tasker</span> <span class="o">=</span> <span class="n">OutOfDateTask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasker</span> <span class="o">=</span> <span class="n">tasker</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_next_candidate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_trace</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>

<div class="viewcode-block" id="Taskmaster.configure_trace"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.configure_trace">[docs]</a>    <span class="k">def</span> <span class="nf">configure_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This handles the command line option --taskmastertrace=</span>
<span class="sd">        It can be:</span>
<span class="sd">        -           : output to stdout</span>
<span class="sd">        &lt;filename&gt;  : output to a file</span>
<span class="sd">        False/None  : Do not trace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>

        <span class="c1"># TODO: May want to switch format to something like this.</span>
        <span class="c1"># log_format = (</span>
        <span class="c1">#     &#39;%(relativeCreated)05dms&#39;</span>
        <span class="c1">#     &#39;:%(relfilename)s&#39;</span>
        <span class="c1">#     &#39;:%(funcName)s&#39;</span>
        <span class="c1">#     &#39;#%(lineno)s&#39;</span>
        <span class="c1">#     &#39;: %(message)s&#39;</span>
        <span class="c1"># )</span>
        <span class="n">tm_formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;Taskmaster: </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">):</span>
            <span class="n">log_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">trace</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">log_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">trace</span><span class="p">:</span>
            <span class="n">log_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>

        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;Taskmaster&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">log_handler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">=</span> <span class="n">logger</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">log_handler</span> <span class="o">=</span> <span class="n">log_handler</span>

        <span class="c1"># Now setup Task&#39;s logger.</span>
        <span class="n">tl</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;Task&quot;</span><span class="p">)</span>
        <span class="n">tl</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">tl</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">log_handler</span><span class="p">)</span>
        <span class="n">task_formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(name)s</span><span class="s1">.</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">Task</span><span class="o">.</span><span class="n">LOGGER</span> <span class="o">=</span> <span class="n">tl</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">log_handler</span> <span class="o">=</span> <span class="n">log_handler</span>

        <span class="n">log_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">DispatchingFormatter</span><span class="p">(</span>
            <span class="n">formatters</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;Taskmaster&#39;</span><span class="p">:</span> <span class="n">tm_formatter</span><span class="p">,</span>
                <span class="s1">&#39;Task&#39;</span><span class="p">:</span> <span class="n">task_formatter</span><span class="p">,</span>
                <span class="s1">&#39;Job&#39;</span><span class="p">:</span> <span class="n">task_formatter</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">default_formatter</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="p">))</span></div>

<div class="viewcode-block" id="Taskmaster.find_next_candidate"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.find_next_candidate">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_candidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next candidate Node for (potential) evaluation.</span>

<span class="sd">        The candidate list (really a stack) initially consists of all of</span>
<span class="sd">        the top-level (command line) targets provided when the Taskmaster</span>
<span class="sd">        was initialized.  While we walk the DAG, visiting Nodes, all the</span>
<span class="sd">        children that haven&#39;t finished processing get pushed on to the</span>
<span class="sd">        candidate list.  Each child can then be popped and examined in</span>
<span class="sd">        turn for whether *their* children are all up-to-date, in which</span>
<span class="sd">        case a Task will be created for their actual evaluation and</span>
<span class="sd">        potential building.</span>

<span class="sd">        Here is where we also allow candidate Nodes to alter the list of</span>
<span class="sd">        Nodes that should be examined.  This is used, for example, when</span>
<span class="sd">        invoking SCons in a source directory.  A source directory Node can</span>
<span class="sd">        return its corresponding build directory Node, essentially saying,</span>
<span class="sd">        &quot;Hey, you really need to build this thing over here instead.&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_targets_left</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_top</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">alt</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">alter_targets</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">alt</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">alt</span><span class="p">))</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">node</span></div>

<div class="viewcode-block" id="Taskmaster.no_next_candidate"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.no_next_candidate">[docs]</a>    <span class="k">def</span> <span class="nf">no_next_candidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops Taskmaster processing by not returning a next candidate.</span>

<span class="sd">        Note that we have to clean-up the Taskmaster candidate list</span>
<span class="sd">        because the cycle detection depends on the fact all nodes have</span>
<span class="sd">        been processed somehow.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span><span class="p">:</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">will_not_build</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Taskmaster._validate_pending_children"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster._validate_pending_children">[docs]</a>    <span class="k">def</span> <span class="nf">_validate_pending_children</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the content of the pending_children set. Assert if an</span>
<span class="sd">        internal error is found.</span>

<span class="sd">        This function is used strictly for debugging the taskmaster by</span>
<span class="sd">        checking that no invariants are violated. It is not used in</span>
<span class="sd">        normal operation.</span>

<span class="sd">        The pending_children set is used to detect cycles in the</span>
<span class="sd">        dependency graph. We call a &quot;pending child&quot; a child that is</span>
<span class="sd">        found in the &quot;pending&quot; state when checking the dependencies of</span>
<span class="sd">        its parent node.</span>

<span class="sd">        A pending child can occur when the Taskmaster completes a loop</span>
<span class="sd">        through a cycle. For example, let&#39;s imagine a graph made of</span>
<span class="sd">        three nodes (A, B and C) making a cycle. The evaluation starts</span>
<span class="sd">        at node A. The Taskmaster first considers whether node A&#39;s</span>
<span class="sd">        child B is up-to-date. Then, recursively, node B needs to</span>
<span class="sd">        check whether node C is up-to-date. This leaves us with a</span>
<span class="sd">        dependency graph looking like::</span>

<span class="sd">                                          Next candidate \</span>
<span class="sd">                                                          \</span>
<span class="sd">            Node A (Pending) --&gt; Node B(Pending) --&gt; Node C (NoState)</span>
<span class="sd">                    ^                                     |</span>
<span class="sd">                    |                                     |</span>
<span class="sd">                    +-------------------------------------+</span>

<span class="sd">        Now, when the Taskmaster examines the Node C&#39;s child Node A,</span>
<span class="sd">        it finds that Node A is in the &quot;pending&quot; state. Therefore,</span>
<span class="sd">        Node A is a pending child of node C.</span>

<span class="sd">        Pending children indicate that the Taskmaster has potentially</span>
<span class="sd">        loop back through a cycle. We say potentially because it could</span>
<span class="sd">        also occur when a DAG is evaluated in parallel. For example,</span>
<span class="sd">        consider the following graph::</span>

<span class="sd">            Node A (Pending) --&gt; Node B(Pending) --&gt; Node C (Pending) --&gt; ...</span>
<span class="sd">                    |                                     ^</span>
<span class="sd">                    |                                     |</span>
<span class="sd">                    +----------&gt; Node D (NoState) --------+</span>
<span class="sd">                                      /</span>
<span class="sd">                      Next candidate /</span>

<span class="sd">        The Taskmaster first evaluates the nodes A, B, and C and</span>
<span class="sd">        starts building some children of node C. Assuming, that the</span>
<span class="sd">        maximum parallel level has not been reached, the Taskmaster</span>
<span class="sd">        will examine Node D. It will find that Node C is a pending</span>
<span class="sd">        child of Node D.</span>

<span class="sd">        In summary, evaluating a graph with a cycle will always</span>
<span class="sd">        involve a pending child at one point. A pending child might</span>
<span class="sd">        indicate either a cycle or a diamond-shaped DAG. Only a</span>
<span class="sd">        fraction of the nodes ends-up being a &quot;pending child&quot; of</span>
<span class="sd">        another node. This keeps the pending_children set small in</span>
<span class="sd">        practice.</span>

<span class="sd">        We can differentiate between the two cases if we wait until</span>
<span class="sd">        the end of the build. At this point, all the pending children</span>
<span class="sd">        nodes due to a diamond-shaped DAG will have been properly</span>
<span class="sd">        built (or will have failed to build). But, the pending</span>
<span class="sd">        children involved in a cycle will still be in the pending</span>
<span class="sd">        state.</span>

<span class="sd">        The taskmaster removes nodes from the pending_children set as</span>
<span class="sd">        soon as a pending_children node moves out of the pending</span>
<span class="sd">        state. This also helps to keep the pending_children set small.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="p">(</span><span class="n">NODE_PENDING</span><span class="p">,</span> <span class="n">NODE_EXECUTING</span><span class="p">),</span> \
                <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">StateString</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">state</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">waiting_parents</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span><span class="p">)</span></div>

<div class="viewcode-block" id="Taskmaster.tm_trace_node"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.tm_trace_node">[docs]</a>    <span class="k">def</span> <span class="nf">tm_trace_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="s1">&#39;&lt;</span><span class="si">%-10s</span><span class="s1"> </span><span class="si">%-3s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">StateString</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">get_state</span><span class="p">()],</span>
                                    <span class="n">node</span><span class="o">.</span><span class="n">ref_count</span><span class="p">,</span>
                                    <span class="nb">repr</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">))))</span></div>

<div class="viewcode-block" id="Taskmaster._find_next_ready_node"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster._find_next_ready_node">[docs]</a>    <span class="k">def</span> <span class="nf">_find_next_ready_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the next node that is ready to be built.</span>

<span class="sd">        This is *the* main guts of the DAG walk.  We loop through the</span>
<span class="sd">        list of candidates, looking for something that has no un-built</span>
<span class="sd">        children (i.e., that is a leaf Node or has dependencies that are</span>
<span class="sd">        all leaf Nodes or up-to-date).  Candidate Nodes are re-scanned</span>
<span class="sd">        (both the target Node itself and its sources, which are always</span>
<span class="sd">        scanned in the context of a given target) to discover implicit</span>
<span class="sd">        dependencies.  A Node that must wait for some children to be</span>
<span class="sd">        built will be put back on the candidates list after the children</span>
<span class="sd">        have finished building.  A Node that has been put back on the</span>
<span class="sd">        candidates list in this way may have itself (or its sources)</span>
<span class="sd">        re-scanned, in order to handle generated header files (e.g.) and</span>
<span class="sd">        the implicit dependencies therein.</span>

<span class="sd">        Note that this method does not do any signature calculation or</span>
<span class="sd">        up-to-date check itself.  All of that is handled by the Task</span>
<span class="sd">        class.  This is purely concerned with the dependency graph walk.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ready_exc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">T</span><span class="o">.</span><span class="n">log_handler</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># Prefix message with new line. This is a hack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Looking for a node to evaluate&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_candidate</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No candidate anymore.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">disambiguate</span><span class="p">()</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>

            <span class="c1"># For debugging only:</span>
            <span class="c1">#</span>
            <span class="c1"># try:</span>
            <span class="c1">#     self._validate_pending_children()</span>
            <span class="c1"># except:</span>
            <span class="c1">#     self.ready_exc = sys.exc_info()</span>
            <span class="c1">#     return node</span>

            <span class="k">if</span> <span class="n">CollectStats</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="s1">&#39;stats&#39;</span><span class="p">):</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">Stats</span><span class="p">()</span>
                    <span class="n">StatsNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">stats</span>
                <span class="n">S</span><span class="o">.</span><span class="n">considered</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">considered</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;    Considering node </span><span class="si">%s</span><span class="s1"> and its children:&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">NODE_NO_STATE</span><span class="p">:</span>
                <span class="c1"># Mark this node as being on the execution stack:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_PENDING</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">state</span> <span class="o">&gt;</span> <span class="n">NODE_PENDING</span><span class="p">:</span>
                <span class="c1"># Skip this node if it has already been evaluated:</span>
                <span class="k">if</span> <span class="n">S</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">already_handled</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">already_handled</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;       already handled (executed)&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">executor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_executor</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">children</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">get_all_children</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">SystemExit</span><span class="p">:</span>
                <span class="n">exc_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">ExplicitExit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">exc_value</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ready_exc</span> <span class="o">=</span> <span class="p">(</span><span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">ExplicitExit</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;       SystemExit&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># We had a problem just trying to figure out the</span>
                <span class="c1"># children (like a child couldn&#39;t be linked in to a</span>
                <span class="c1"># VariantDir, or a Scanner threw something).  Arrange to</span>
                <span class="c1"># raise the exception when the Task is &quot;executed.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ready_exc</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">S</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">problem</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;       exception </span><span class="si">%s</span><span class="s1"> while scanning children.&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">node</span>

            <span class="n">children_not_visited</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">children_pending</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">children_not_ready</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">children_failed</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">get_all_prerequisites</span><span class="p">(),</span> <span class="n">children</span><span class="p">):</span>
                <span class="n">childstate</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;       &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">childstate</span> <span class="o">==</span> <span class="n">NODE_NO_STATE</span><span class="p">:</span>
                    <span class="n">children_not_visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">childstate</span> <span class="o">==</span> <span class="n">NODE_PENDING</span><span class="p">:</span>
                    <span class="n">children_pending</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">childstate</span> <span class="o">==</span> <span class="n">NODE_FAILED</span><span class="p">:</span>
                    <span class="n">children_failed</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">childstate</span> <span class="o">&lt;=</span> <span class="n">NODE_EXECUTING</span><span class="p">:</span>
                    <span class="n">children_not_ready</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="c1"># These nodes have not even been visited yet.  Add</span>
            <span class="c1"># them to the list so that on some next pass we can</span>
            <span class="c1"># take a stab at evaluating them (or their children).</span>
            <span class="k">if</span> <span class="n">children_not_visited</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children_not_visited</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">children_not_visited</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">candidates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">children_not_visited</span><span class="p">))</span>

            <span class="c1"># if T and children_not_visited:</span>
            <span class="c1">#    self.trace.debug(&#39;     adding to candidates: %s&#39; % map(str, children_not_visited))</span>
            <span class="c1">#    self.trace.debug(&#39;     candidates now: %s\n&#39; % map(str, self.candidates))</span>

            <span class="c1"># Skip this node if any of its children have failed.</span>
            <span class="c1">#</span>
            <span class="c1"># This catches the case where we&#39;re descending a top-level</span>
            <span class="c1"># target and one of our children failed while trying to be</span>
            <span class="c1"># built by a *previous* descent of an earlier top-level</span>
            <span class="c1"># target.</span>
            <span class="c1">#</span>
            <span class="c1"># It can also occur if a node is reused in multiple</span>
            <span class="c1"># targets. One first descends though the one of the</span>
            <span class="c1"># target, the next time occurs through the other target.</span>
            <span class="c1">#</span>
            <span class="c1"># Note that we can only have failed_children if the</span>
            <span class="c1"># --keep-going flag was used, because without it the build</span>
            <span class="c1"># will stop before diving in the other branch.</span>
            <span class="c1">#</span>
            <span class="c1"># Note that even if one of the children fails, we still</span>
            <span class="c1"># added the other children to the list of candidate nodes</span>
            <span class="c1"># to keep on building (--keep-going).</span>
            <span class="k">if</span> <span class="n">children_failed</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">executor</span><span class="o">.</span><span class="n">get_action_targets</span><span class="p">():</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">NODE_FAILED</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">S</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">child_failed</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">child_failed</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;****** </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">children_not_ready</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children_not_ready</span><span class="p">:</span>
                    <span class="c1"># We&#39;re waiting on one or more derived targets</span>
                    <span class="c1"># that have not yet finished building.</span>
                    <span class="k">if</span> <span class="n">S</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">not_built</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">not_built</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="c1"># Add this node to the waiting parents lists of</span>
                    <span class="c1"># anything we&#39;re waiting on, with a reference</span>
                    <span class="c1"># count so we can be put back on the list for</span>
                    <span class="c1"># re-evaluation when they&#39;ve all finished.</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">=</span>  <span class="n">node</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">add_to_waiting_parents</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;     adjusted ref count: </span><span class="si">%s</span><span class="s1">, child </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">child</span><span class="p">))))</span>

                <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">children_pending</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;       adding </span><span class="si">%s</span><span class="s1"> to the pending children set&#39;</span> <span class="o">%</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span> <span class="o">|</span> <span class="n">children_pending</span>

                <span class="k">continue</span>

            <span class="c1"># Skip this node if it has side-effects that are</span>
            <span class="c1"># currently being built:</span>
            <span class="n">wait_side_effects</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">se</span> <span class="ow">in</span> <span class="n">executor</span><span class="o">.</span><span class="n">get_action_side_effects</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">se</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span> <span class="o">==</span> <span class="n">NODE_EXECUTING</span><span class="p">:</span>
                    <span class="n">se</span><span class="o">.</span><span class="n">add_to_waiting_s_e</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">wait_side_effects</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">wait_side_effects</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">S</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">side_effects</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">side_effects</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="c1"># The default when we&#39;ve gotten through all of the checks above:</span>
            <span class="c1"># this node is ready to be built.</span>
            <span class="k">if</span> <span class="n">S</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">build</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">build</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Evaluating </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

            <span class="c1"># For debugging only:</span>
            <span class="c1">#</span>
            <span class="c1"># try:</span>
            <span class="c1">#     self._validate_pending_children()</span>
            <span class="c1"># except:</span>
            <span class="c1">#     self.ready_exc = sys.exc_info()</span>
            <span class="c1">#     return node</span>

            <span class="k">return</span> <span class="n">node</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Taskmaster.next_task"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.next_task">[docs]</a>    <span class="k">def</span> <span class="nf">next_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next task to be executed.</span>

<span class="sd">        This simply asks for the next Node to be evaluated, and then wraps</span>
<span class="sd">        it in the specific Task subclass with which we were initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_next_ready_node</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">executor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_executor</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">tlist</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">get_all_targets</span><span class="p">()</span>

        <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_top</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">make_ready</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="c1"># We had a problem just trying to get this task ready (like</span>
            <span class="c1"># a child couldn&#39;t be linked to a VariantDir when deciding</span>
            <span class="c1"># whether this node is current).  Arrange to raise the</span>
            <span class="c1"># exception when the Task is &quot;executed.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ready_exc</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ready_exc</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">exception_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ready_exc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ready_exc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">task</span></div>

<div class="viewcode-block" id="Taskmaster.will_not_build"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.will_not_build">[docs]</a>    <span class="k">def</span> <span class="nf">will_not_build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">node_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform clean-up about nodes that will never be built. Invokes</span>
<span class="sd">        a user defined function on all of these nodes (including all</span>
<span class="sd">        of their parents).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span>

        <span class="n">pending_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span>

        <span class="n">to_visit</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">pending_children</span> <span class="o">=</span> <span class="n">pending_children</span> <span class="o">-</span> <span class="n">to_visit</span>

        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;       removing node </span><span class="si">%s</span><span class="s1"> from the pending children set</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">node_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># Prune recursion by flushing the waiting children</span>
                <span class="c1"># list immediately.</span>
                <span class="n">parents</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">waiting_parents</span>
                <span class="n">node</span><span class="o">.</span><span class="n">waiting_parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="n">to_visit</span> <span class="o">=</span> <span class="n">to_visit</span> <span class="o">|</span> <span class="n">parents</span>
                <span class="n">pending_children</span> <span class="o">=</span> <span class="n">pending_children</span> <span class="o">-</span> <span class="n">parents</span>

                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;       removing parent </span><span class="si">%s</span><span class="s1"> from the pending children set</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">tm_trace_node</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># The container to_visit has been emptied.</span>
            <span class="k">pass</span>

        <span class="c1"># We have the stick back the pending_children list into the</span>
        <span class="c1"># taskmaster because the python 1.5.2 compatibility does not</span>
        <span class="c1"># allow us to use in-place updates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span> <span class="o">=</span> <span class="n">pending_children</span></div>

<div class="viewcode-block" id="Taskmaster.stop"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops the current build completely.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_next_candidate</span></div>

<div class="viewcode-block" id="Taskmaster.cleanup"><a class="viewcode-back" href="../../../SCons.Taskmaster/#SCons.Taskmaster.Taskmaster.cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for dependency cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">nclist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">find_cycle</span><span class="p">([</span><span class="n">n</span><span class="p">],</span> <span class="nb">set</span><span class="p">()))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_children</span><span class="p">]</span>

        <span class="n">genuine_cycles</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">cycle</span> <span class="ow">in</span> <span class="n">nclist</span>
                     <span class="k">if</span> <span class="n">cycle</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span> <span class="o">!=</span> <span class="n">NODE_EXECUTED</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">genuine_cycles</span><span class="p">:</span>
            <span class="c1"># All of the &quot;cycles&quot; found were single nodes in EXECUTED state,</span>
            <span class="c1"># which is to say, they really weren&#39;t cycles.  Just return.</span>
            <span class="k">return</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="s1">&#39;Found dependency cycle(s):</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">nclist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
                <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot; -&gt; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">cycle</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> \
                    <span class="s2">&quot;  Internal Error: no cycle found for node </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">) in state </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>  \
                    <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">StateString</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">get_state</span><span class="p">()])</span>

        <span class="k">raise</span> <span class="n">SCons</span><span class="o">.</span><span class="n">Errors</span><span class="o">.</span><span class="n">UserError</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div></div>

<span class="c1"># Local Variables:</span>
<span class="c1"># tab-width:4</span>
<span class="c1"># indent-tabs-mode:nil</span>
<span class="c1"># End:</span>
<span class="c1"># vim: set expandtab tabstop=4 shiftwidth=4:</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By SCons Project Team
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022, SCons Project.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>