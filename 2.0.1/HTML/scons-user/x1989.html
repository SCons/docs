<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Providing Build Progress Output:  the Progress Function</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="SCons User Guide 2.0.1"
HREF="index.html"><LINK
REL="UP"
TITLE="Controlling Build Output"
HREF="c1910.html"><LINK
REL="PREVIOUS"
TITLE="Controlling How SCons Prints Build Commands:  the $*COMSTR Variables"
HREF="x1952.html"><LINK
REL="NEXT"
TITLE="Printing Detailed Build Status:  the GetBuildFailures Function"
HREF="x2045.html"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SCons User Guide 2.0.1</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1952.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 11. Controlling Build Output</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2045.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN1989"
>11.3. Providing Build Progress Output:  the <CODE
CLASS="function"
>Progress</CODE
> Function</A
></H1
><P
>&#13;
    Another aspect of providing good build output
    is to give the user feedback
    about what <SPAN
CLASS="application"
>SCons</SPAN
> is doing
    even when nothing is being built at the moment.
    This can be especially true for large builds
    when most of the targets are already up-to-date.
    Because <SPAN
CLASS="application"
>SCons</SPAN
> can take a long time
    making absolutely sure that every
    target is, in fact, up-to-date
    with respect to a lot of dependency files,
    it can be easy for users to mistakenly
    conclude that <SPAN
CLASS="application"
>SCons</SPAN
> is hung
    or that there is some other problem with the build.

    </P
><P
>&#13;
    One way to deal with this perception
    is to configure <SPAN
CLASS="application"
>SCons</SPAN
> to print something to
    let the user know what it's "thinking about."
    The <CODE
CLASS="function"
>Progress</CODE
> function
    allows you to specify a string
    that will be printed for every file
    that <SPAN
CLASS="application"
>SCons</SPAN
> is "considering"
    while it is traversing the dependency graph
    to decide what targets are or are not up-to-date.

    </P
><PRE
CLASS="programlisting"
>&#13;        Progress('Evaluating $TARGET\n')
        Program('f1.c')
        Program('f2.c')
    </PRE
><P
>&#13;
    Note that the <CODE
CLASS="function"
>Progress</CODE
> function does not
    arrange for a newline to be printed automatically
    at the end of the string (as does the Python
    <TT
CLASS="literal"
>print</TT
> statement),
    and we must specify the
    <TT
CLASS="literal"
>\n</TT
>
    that we want printed at the end of the configured string.
    This configuration, then,
    will have <SPAN
CLASS="application"
>SCons</SPAN
>
    print that it is <TT
CLASS="literal"
>Evaluating</TT
>
    each file that it encounters
    in turn as it traverses the dependency graph:

    </P
><PRE
CLASS="screen"
>&#13;       % <KBD
CLASS="userinput"
>scons -Q</KBD
>
       Evaluating SConstruct
       Evaluating f1.c
       Evaluating f1.o
       cc -o f1.o -c f1.c
       Evaluating f1
       cc -o f1 f1.o
       Evaluating f2.c
       Evaluating f2.o
       cc -o f2.o -c f2.c
       Evaluating f2
       cc -o f2 f2.o
       Evaluating .
    </PRE
><P
>&#13;
    Of course, normally you don't want to add
    all of these additional lines to your build output,
    as that can make it difficult for the user
    to find errors or other important messages.
    A more useful way to display
    this progress might be
    to have the file names printed
    directly to the user's screen,
    not to the same standard output
    stream where build output is printed,
    and to use a carriage return character
    (<TT
CLASS="literal"
>\r</TT
>)
    so that each file name gets re-printed on the same line.
    Such a configuration would look like:

    </P
><PRE
CLASS="programlisting"
>&#13;        Progress('$TARGET\r',
                 file=open('/dev/tty', 'w'),
                 overwrite=True)
        Program('f1.c')
        Program('f2.c')
    </PRE
><P
>&#13;
    Note that we also specified the
    <TT
CLASS="literal"
>overwrite=True</TT
> argument
    to the <CODE
CLASS="function"
>Progress</CODE
> function,
    which causes <SPAN
CLASS="application"
>SCons</SPAN
> to
    "wipe out" the previous string with space characters
    before printing the next <CODE
CLASS="function"
>Progress</CODE
> string.
    Without the
    <TT
CLASS="literal"
>overwrite=True</TT
> argument,
    a shorter file name would not overwrite
    all of the charactes in a longer file name that 
    precedes it,
    making it difficult to tell what the
    actual file name is on the output.
    Also note that we opened up the
    <TT
CLASS="filename"
>/dev/tty</TT
> file
    for direct access (on POSIX) to
    the user's screen.
    On Windows, the equivalent would be to open
    the <TT
CLASS="filename"
>con:</TT
> file name.

    </P
><P
>&#13;
    Also, it's important to know that although you can use
    <TT
CLASS="literal"
>$TARGET</TT
> to substitute the name of
    the node in the string,
    the <CODE
CLASS="function"
>Progress</CODE
> function does <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>not</I
></SPAN
>
    perform general variable substitution
    (because there's not necessarily a construction
    environment involved in evaluating a node
    like a source file, for example).

    </P
><P
>&#13;
    You can also specify a list of strings
    to the <CODE
CLASS="function"
>Progress</CODE
> function,
    in which case <SPAN
CLASS="application"
>SCons</SPAN
> will
    display each string in turn.
    This can be used to implement a "spinner"
    by having <SPAN
CLASS="application"
>SCons</SPAN
> cycle through a
    sequence of strings:

    </P
><PRE
CLASS="programlisting"
>&#13;        Progress(['-\r', '\\\r', '|\r', '/\r'], interval=5)
        Program('f1.c')
        Program('f2.c')
    </PRE
><P
>&#13;
    Note that here we have also used the
    <TT
CLASS="literal"
>interval=</TT
>
    keyword argument to have <SPAN
CLASS="application"
>SCons</SPAN
>
    only print a new "spinner" string
    once every five evaluated nodes.
    Using an <TT
CLASS="literal"
>interval=</TT
> count,
    even with strings that use <TT
CLASS="literal"
>$TARGET</TT
> like
    our examples above,
    can be a good way to lessen the
    work that <SPAN
CLASS="application"
>SCons</SPAN
> expends printing <CODE
CLASS="function"
>Progress</CODE
> strings,
    while still giving the user feedback
    that indicates <SPAN
CLASS="application"
>SCons</SPAN
> is still
    working on evaluating the build.

    </P
><P
>&#13;
    Lastly, you can have direct control
    over how to print each evaluated node
    by passing a Python function
    (or other Python callable)
    to the <CODE
CLASS="function"
>Progress</CODE
> function.
    Your function will be called
    for each evaluated node,
    allowing you to
    implement more sophisticated logic
    like adding a counter:

    </P
><PRE
CLASS="programlisting"
>&#13;        screen = open('/dev/tty', 'w')
        count = 0
        def progress_function(node)
            count += 1
            screen.write('Node %4d: %s\r' % (count, node))

        Progress(progress_function)
    </PRE
><P
>&#13;
    Of course, if you choose,
    you could completely ignore the
    <CODE
CLASS="varname"
>node</CODE
> argument to the function,
    and just print a count,
    or anything else you wish.

    </P
><P
>&#13;
    (Note that there's an obvious follow-on question here:
    how would you find the total number of nodes
    that <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>will be</I
></SPAN
>
    evaluated so you can tell the user how
    close the build is to finishing?
    Unfortunately, in the general case,
    there isn't a good way to do that,
    short of having <SPAN
CLASS="application"
>SCons</SPAN
> evaluate its
    dependency graph twice,
    first to count the total and
    the second time to actually build the targets.
    This would be necessary because
    you can't know in advance which
    target(s) the user actually requested
    to be built.
    The entire build may consist of thousands of Nodes,
    for example,
    but maybe the user specifically requested
    that only a single object file be built.)

    </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1952.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2045.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Controlling How <SPAN
CLASS="application"
>SCons</SPAN
> Prints Build Commands:  the <CODE
CLASS="envar"
>$*COMSTR</CODE
> Variables</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1910.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Printing Detailed Build Status:  the <CODE
CLASS="function"
>GetBuildFailures</CODE
> Function</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>