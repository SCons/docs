
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>SCons.Taskmaster package &#8212; SCons 4.5.0 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="SCons.Tool package" href="../SCons.Tool/" />
    <link rel="prev" title="SCons.Script package" href="../SCons.Script/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../">
      
      
      
      <h1 class="site-logo" id="site-title">SCons 4.5.0 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search/" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p class="caption" role="heading">
 <span class="caption-text">
  Contents:
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../SCons/">
   SCons package
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="../SCons.Node/">
     SCons.Node package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../SCons.Platform/">
     SCons.Platform package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../SCons.Scanner/">
     SCons.Scanner package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../SCons.Script/">
     SCons.Script package
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     SCons.Taskmaster package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../SCons.Tool/">
     SCons.Tool package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../SCons.Variables/">
     SCons.Variables package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../SCons.compat/">
     SCons.compat package
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SCons.compat/">
   SCons.compat package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SCons.Node/">
   SCons.Node package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SCons.Platform/">
   SCons.Platform package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SCons.Scanner/">
   SCons.Scanner package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SCons.Script/">
   SCons.Script package
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   SCons.Taskmaster package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SCons.Tool/">
   SCons.Tool package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SCons.Variables/">
   SCons.Variables package
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/SCons.Taskmaster.rst.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#submodules">
   Submodules
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-SCons.Taskmaster.Job">
   SCons.Taskmaster.Job module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-SCons.Taskmaster">
   Module contents
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>SCons.Taskmaster package</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#submodules">
   Submodules
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-SCons.Taskmaster.Job">
   SCons.Taskmaster.Job module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-SCons.Taskmaster">
   Module contents
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="scons-taskmaster-package">
<h1>SCons.Taskmaster package<a class="headerlink" href="#scons-taskmaster-package" title="Permalink to this headline">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">#</a></h2>
</section>
<section id="module-SCons.Taskmaster.Job">
<span id="scons-taskmaster-job-module"></span><h2>SCons.Taskmaster.Job module<a class="headerlink" href="#module-SCons.Taskmaster.Job" title="Permalink to this headline">#</a></h2>
<p>Serial and Parallel classes to execute build tasks.</p>
<p>The Jobs class provides a higher level interface to start,
stop, and wait on jobs.</p>
<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.InterruptState">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.Job.</span></span><span class="sig-name descname"><span class="pre">InterruptState</span></span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#InterruptState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.InterruptState" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.InterruptState.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#InterruptState.set"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.InterruptState.set" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Jobs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.Job.</span></span><span class="sig-name descname"><span class="pre">Jobs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taskmaster</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Jobs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Jobs" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An instance of this class initializes N jobs, and provides
methods for starting, stopping, and waiting on all N jobs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Jobs._reset_sig_handler">
<span class="sig-name descname"><span class="pre">_reset_sig_handler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Jobs._reset_sig_handler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Jobs._reset_sig_handler" title="Permalink to this definition">#</a></dt>
<dd><p>Restore the signal handlers to their previous state (before the
call to _setup_sig_handler().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Jobs._setup_sig_handler">
<span class="sig-name descname"><span class="pre">_setup_sig_handler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Jobs._setup_sig_handler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Jobs._setup_sig_handler" title="Permalink to this definition">#</a></dt>
<dd><p>Setup an interrupt handler so that SCons can shutdown cleanly in
various conditions:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>SIGINT: Keyboard interrupt</p></li>
<li><p>SIGTERM: kill or system shutdown</p></li>
<li><p>SIGHUP: Controlling shell exiting</p></li>
</ol>
</div></blockquote>
<p>We handle all of these cases by stopping the taskmaster. It
turns out that it’s very difficult to stop the build process
by throwing asynchronously an exception such as
KeyboardInterrupt. For example, the python Condition
variables (threading.Condition) and queues do not seem to be
asynchronous-exception-safe. It would require adding a whole
bunch of try/finally block and except KeyboardInterrupt all
over the place.</p>
<p>Note also that we have to be careful to handle the case when
SCons forks before executing another process. In that case, we
want the child to exit immediately.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Jobs.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">postfunc=&lt;function</span> <span class="pre">Jobs.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Jobs.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Jobs.run" title="Permalink to this definition">#</a></dt>
<dd><p>Run the jobs.</p>
<p>postfunc() will be invoked after the jobs has run. It will be
invoked even if the jobs are interrupted by a keyboard
interrupt (well, in fact by a signal such as either SIGINT,
SIGTERM or SIGHUP). The execution of postfunc() is protected
against keyboard interrupts and is guaranteed to run to
completion.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Jobs.were_interrupted">
<span class="sig-name descname"><span class="pre">were_interrupted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Jobs.were_interrupted"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Jobs.were_interrupted" title="Permalink to this definition">#</a></dt>
<dd><p>Returns whether the jobs were interrupted by a signal.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.LegacyParallel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.Job.</span></span><span class="sig-name descname"><span class="pre">LegacyParallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">taskmaster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stack_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#LegacyParallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.LegacyParallel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is used to execute tasks in parallel, and is somewhat
less efficient than Serial, but is appropriate for parallel builds.</p>
<p>This class is thread safe.</p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.LegacyParallel.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#LegacyParallel.start"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.LegacyParallel.start" title="Permalink to this definition">#</a></dt>
<dd><p>Start the job. This will begin pulling tasks from the
taskmaster and executing them, and return when there are no
more tasks. If a task fails to execute (i.e. execute() raises
an exception), then the job will stop.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.Job.</span></span><span class="sig-name descname"><span class="pre">NewParallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">taskmaster</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stack_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.State">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">State</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel.State"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.State" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.State.COMPLETED">
<span class="sig-name descname"><span class="pre">COMPLETED</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.State.COMPLETED" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.State.READY">
<span class="sig-name descname"><span class="pre">READY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.State.READY" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.State.SEARCHING">
<span class="sig-name descname"><span class="pre">SEARCHING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.State.SEARCHING" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.State.STALLED">
<span class="sig-name descname"><span class="pre">STALLED</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.State.STALLED" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Worker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">owner</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel.Worker"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._bootstrap">
<span class="sig-name descname"><span class="pre">_bootstrap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._bootstrap" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._bootstrap_inner">
<span class="sig-name descname"><span class="pre">_bootstrap_inner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._bootstrap_inner" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._delete">
<span class="sig-name descname"><span class="pre">_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._delete" title="Permalink to this definition">#</a></dt>
<dd><p>Remove current thread from the dict of currently running threads.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._initialized">
<span class="sig-name descname"><span class="pre">_initialized</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._initialized" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._reset_internal_locks">
<span class="sig-name descname"><span class="pre">_reset_internal_locks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_alive</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._reset_internal_locks" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._set_ident">
<span class="sig-name descname"><span class="pre">_set_ident</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._set_ident" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._set_native_id">
<span class="sig-name descname"><span class="pre">_set_native_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._set_native_id" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._set_tstate_lock">
<span class="sig-name descname"><span class="pre">_set_tstate_lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._set_tstate_lock" title="Permalink to this definition">#</a></dt>
<dd><p>Set a lock object which will be released by the interpreter when
the underlying thread state (see pystate.h) gets deleted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._stop">
<span class="sig-name descname"><span class="pre">_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._stop" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker._wait_for_tstate_lock">
<span class="sig-name descname"><span class="pre">_wait_for_tstate_lock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker._wait_for_tstate_lock" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.daemon">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">daemon</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.daemon" title="Permalink to this definition">#</a></dt>
<dd><p>A boolean value indicating whether this thread is a daemon thread.</p>
<p>This must be set before start() is called, otherwise RuntimeError is
raised. Its initial value is inherited from the creating thread; the
main thread is not a daemon thread and therefore all threads created in
the main thread default to daemon = False.</p>
<p>The entire Python program exits when only daemon threads are left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.getName">
<span class="sig-name descname"><span class="pre">getName</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.getName" title="Permalink to this definition">#</a></dt>
<dd><p>Return a string used for identification purposes only.</p>
<p>This method is deprecated, use the name attribute instead.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.ident">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ident</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.ident" title="Permalink to this definition">#</a></dt>
<dd><p>Thread identifier of this thread or None if it has not been started.</p>
<p>This is a nonzero integer. See the get_ident() function. Thread
identifiers may be recycled when a thread exits and another thread is
created. The identifier is available even after the thread has exited.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.isDaemon">
<span class="sig-name descname"><span class="pre">isDaemon</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.isDaemon" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether this thread is a daemon.</p>
<p>This method is deprecated, use the daemon attribute instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.is_alive">
<span class="sig-name descname"><span class="pre">is_alive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.is_alive" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. See also the module function
enumerate().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.join" title="Permalink to this definition">#</a></dt>
<dd><p>Wait until the thread terminates.</p>
<p>This blocks the calling thread until the thread whose join() method is
called terminates – either normally or through an unhandled exception
or until the optional timeout occurs.</p>
<p>When the timeout argument is present and not None, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof). As join() always returns None, you must call
is_alive() after join() to decide whether a timeout happened – if the
thread is still alive, the join() call timed out.</p>
<p>When the timeout argument is not present or None, the operation will
block until the thread terminates.</p>
<p>A thread can be join()ed many times.</p>
<p>join() raises a RuntimeError if an attempt is made to join the current
thread as that would cause a deadlock. It is also an error to join() a
thread before it has been started and attempts to do so raises the same
exception.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.name" title="Permalink to this definition">#</a></dt>
<dd><p>A string used for identification purposes only.</p>
<p>It has no semantics. Multiple threads may be given the same name. The
initial name is set by the constructor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.native_id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">native_id</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.native_id" title="Permalink to this definition">#</a></dt>
<dd><p>Native integral thread ID of this thread, or None if it has not been started.</p>
<p>This is a non-negative integer. See the get_native_id() function.
This represents the Thread ID as reported by the kernel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel.Worker.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.run" title="Permalink to this definition">#</a></dt>
<dd><p>Method representing the thread’s activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object’s constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.setDaemon">
<span class="sig-name descname"><span class="pre">setDaemon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">daemonic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.setDaemon" title="Permalink to this definition">#</a></dt>
<dd><p>Set whether this thread is a daemon.</p>
<p>This method is deprecated, use the .daemon property instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.setName">
<span class="sig-name descname"><span class="pre">setName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.setName" title="Permalink to this definition">#</a></dt>
<dd><p>Set the name string for this thread.</p>
<p>This method is deprecated, use the name attribute instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.Worker.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.Worker.start" title="Permalink to this definition">#</a></dt>
<dd><p>Start the thread’s activity.</p>
<p>It must be called at most once per thread object. It arranges for the
object’s run() method to be invoked in a separate thread of control.</p>
<p>This method will raise a RuntimeError if called more than once on the
same thread object.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel._adjust_stack_size">
<span class="sig-name descname"><span class="pre">_adjust_stack_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel._adjust_stack_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel._adjust_stack_size" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel._restore_stack_size">
<span class="sig-name descname"><span class="pre">_restore_stack_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel._restore_stack_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel._restore_stack_size" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel._setup_logging">
<span class="sig-name descname"><span class="pre">_setup_logging</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel._setup_logging"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel._setup_logging" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel._start_workers">
<span class="sig-name descname"><span class="pre">_start_workers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel._start_workers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel._start_workers" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel._work">
<span class="sig-name descname"><span class="pre">_work</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel._work"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel._work" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel.start"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.start" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.NewParallel.trace_message">
<span class="sig-name descname"><span class="pre">trace_message</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#NewParallel.trace_message"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.NewParallel.trace_message" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Serial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.Job.</span></span><span class="sig-name descname"><span class="pre">Serial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">taskmaster</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Serial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Serial" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is used to execute tasks in series, and is more efficient
than Parallel, but is only appropriate for non-parallel builds. Only
one instance of this class should be in existence at a time.</p>
<p>This class is not thread safe.</p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Serial.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Serial.start"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Serial.start" title="Permalink to this definition">#</a></dt>
<dd><p>Start the job. This will begin pulling tasks from the taskmaster
and executing them, and return when there are no more tasks. If a task
fails to execute (i.e. execute() raises an exception), then the job will
stop.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.ThreadPool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.Job.</span></span><span class="sig-name descname"><span class="pre">ThreadPool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stack_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interrupted</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#ThreadPool"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.ThreadPool" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is responsible for spawning and managing worker threads.</p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.ThreadPool.cleanup">
<span class="sig-name descname"><span class="pre">cleanup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#ThreadPool.cleanup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.ThreadPool.cleanup" title="Permalink to this definition">#</a></dt>
<dd><p>Shuts down the thread pool, giving each worker thread a
chance to shut down gracefully.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.ThreadPool.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#ThreadPool.get"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.ThreadPool.get" title="Permalink to this definition">#</a></dt>
<dd><p>Remove and return a result tuple from the results queue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.ThreadPool.preparation_failed">
<span class="sig-name descname"><span class="pre">preparation_failed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#ThreadPool.preparation_failed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.ThreadPool.preparation_failed" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.ThreadPool.put">
<span class="sig-name descname"><span class="pre">put</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#ThreadPool.put"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.ThreadPool.put" title="Permalink to this definition">#</a></dt>
<dd><p>Put task into request queue.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.Job.</span></span><span class="sig-name descname"><span class="pre">Worker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">requestQueue</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resultsQueue</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interrupted</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Worker"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Worker" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></p>
<p>A worker thread waits on a task to be posted to its request queue,
dequeues the task, executes it, and posts a tuple including the task
and a boolean indicating whether the task executed successfully.</p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._bootstrap">
<span class="sig-name descname"><span class="pre">_bootstrap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._bootstrap" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._bootstrap_inner">
<span class="sig-name descname"><span class="pre">_bootstrap_inner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._bootstrap_inner" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._delete">
<span class="sig-name descname"><span class="pre">_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._delete" title="Permalink to this definition">#</a></dt>
<dd><p>Remove current thread from the dict of currently running threads.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._initialized">
<span class="sig-name descname"><span class="pre">_initialized</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._initialized" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._reset_internal_locks">
<span class="sig-name descname"><span class="pre">_reset_internal_locks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_alive</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._reset_internal_locks" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._set_ident">
<span class="sig-name descname"><span class="pre">_set_ident</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._set_ident" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._set_native_id">
<span class="sig-name descname"><span class="pre">_set_native_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._set_native_id" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._set_tstate_lock">
<span class="sig-name descname"><span class="pre">_set_tstate_lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._set_tstate_lock" title="Permalink to this definition">#</a></dt>
<dd><p>Set a lock object which will be released by the interpreter when
the underlying thread state (see pystate.h) gets deleted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._stop">
<span class="sig-name descname"><span class="pre">_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._stop" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker._wait_for_tstate_lock">
<span class="sig-name descname"><span class="pre">_wait_for_tstate_lock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker._wait_for_tstate_lock" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.daemon">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">daemon</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.daemon" title="Permalink to this definition">#</a></dt>
<dd><p>A boolean value indicating whether this thread is a daemon thread.</p>
<p>This must be set before start() is called, otherwise RuntimeError is
raised. Its initial value is inherited from the creating thread; the
main thread is not a daemon thread and therefore all threads created in
the main thread default to daemon = False.</p>
<p>The entire Python program exits when only daemon threads are left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.getName">
<span class="sig-name descname"><span class="pre">getName</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.getName" title="Permalink to this definition">#</a></dt>
<dd><p>Return a string used for identification purposes only.</p>
<p>This method is deprecated, use the name attribute instead.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.ident">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ident</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.ident" title="Permalink to this definition">#</a></dt>
<dd><p>Thread identifier of this thread or None if it has not been started.</p>
<p>This is a nonzero integer. See the get_ident() function. Thread
identifiers may be recycled when a thread exits and another thread is
created. The identifier is available even after the thread has exited.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.isDaemon">
<span class="sig-name descname"><span class="pre">isDaemon</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.isDaemon" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether this thread is a daemon.</p>
<p>This method is deprecated, use the daemon attribute instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.is_alive">
<span class="sig-name descname"><span class="pre">is_alive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.is_alive" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. See also the module function
enumerate().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.join" title="Permalink to this definition">#</a></dt>
<dd><p>Wait until the thread terminates.</p>
<p>This blocks the calling thread until the thread whose join() method is
called terminates – either normally or through an unhandled exception
or until the optional timeout occurs.</p>
<p>When the timeout argument is present and not None, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof). As join() always returns None, you must call
is_alive() after join() to decide whether a timeout happened – if the
thread is still alive, the join() call timed out.</p>
<p>When the timeout argument is not present or None, the operation will
block until the thread terminates.</p>
<p>A thread can be join()ed many times.</p>
<p>join() raises a RuntimeError if an attempt is made to join the current
thread as that would cause a deadlock. It is also an error to join() a
thread before it has been started and attempts to do so raises the same
exception.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.name" title="Permalink to this definition">#</a></dt>
<dd><p>A string used for identification purposes only.</p>
<p>It has no semantics. Multiple threads may be given the same name. The
initial name is set by the constructor.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.native_id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">native_id</span></span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.native_id" title="Permalink to this definition">#</a></dt>
<dd><p>Native integral thread ID of this thread, or None if it has not been started.</p>
<p>This is a non-negative integer. See the get_native_id() function.
This represents the Thread ID as reported by the kernel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/Job/#Worker.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.run" title="Permalink to this definition">#</a></dt>
<dd><p>Method representing the thread’s activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object’s constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.setDaemon">
<span class="sig-name descname"><span class="pre">setDaemon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">daemonic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.setDaemon" title="Permalink to this definition">#</a></dt>
<dd><p>Set whether this thread is a daemon.</p>
<p>This method is deprecated, use the .daemon property instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.setName">
<span class="sig-name descname"><span class="pre">setName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.setName" title="Permalink to this definition">#</a></dt>
<dd><p>Set the name string for this thread.</p>
<p>This method is deprecated, use the name attribute instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Job.Worker.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Job.Worker.start" title="Permalink to this definition">#</a></dt>
<dd><p>Start the thread’s activity.</p>
<p>It must be called at most once per thread object. It arranges for the
object’s run() method to be invoked in a separate thread of control.</p>
<p>This method will raise a RuntimeError if called more than once on the
same thread object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-SCons.Taskmaster">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-SCons.Taskmaster" title="Permalink to this headline">#</a></h2>
<p>Generic Taskmaster module for the SCons build engine.</p>
<p>This module contains the primary interface(s) between a wrapping user
interface and the SCons build engine.  There are two key classes here:</p>
<dl>
<dt>Taskmaster</dt><dd><p>This is the main engine for walking the dependency graph and
calling things to decide what does or doesn’t need to be built.</p>
</dd>
<dt>Task</dt><dd><p>This is the base class for allowing a wrapping interface to
decide what does or doesn’t actually need to be done.  The
intention is for a wrapping interface to subclass this as
appropriate for different types of behavior it may need.</p>
<p>The canonical example is the SCons native Python interface,
which has Task subclasses that handle its specific behavior,
like printing “‘foo’ is up to date” when a top-level target
doesn’t need to be built, and handling the -c option by removing
targets as its “build” action.  There is also a separate subclass
for suppressing this output when the -q option is used.</p>
<p>The Taskmaster instantiates a Task object for each (set of)
target(s) that it decides need to be evaluated and/or built.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.</span></span><span class="sig-name descname"><span class="pre">AlwaysTask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#AlwaysTask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SCons.Taskmaster.Task" title="SCons.Taskmaster.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCons.Taskmaster.Task</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.LOGGER">
<span class="sig-name descname"><span class="pre">LOGGER</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.LOGGER" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask._abc_impl" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask._exception_raise">
<span class="sig-name descname"><span class="pre">_exception_raise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask._exception_raise" title="Permalink to this definition">#</a></dt>
<dd><p>Raises a pending exception that was recorded while getting a
Task ready for execution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask._no_exception_to_raise">
<span class="sig-name descname"><span class="pre">_no_exception_to_raise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask._no_exception_to_raise" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.display">
<span class="sig-name descname"><span class="pre">display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.display" title="Permalink to this definition">#</a></dt>
<dd><p>Hook to allow the calling interface to display a message.</p>
<p>This hook gets called as part of preparing a task for execution
(that is, a Node to be built).  As part of figuring out what Node
should be built next, the actual target list may be altered,
along with a message describing the alteration.  The calling
interface can subclass Task and provide a concrete implementation
of this method to see those messages.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.exc_clear">
<span class="sig-name descname"><span class="pre">exc_clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.exc_clear" title="Permalink to this definition">#</a></dt>
<dd><p>Clears any recorded exception.</p>
<p>This also changes the “exception_raise” attribute to point
to the appropriate do-nothing method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.exc_info">
<span class="sig-name descname"><span class="pre">exc_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.exc_info" title="Permalink to this definition">#</a></dt>
<dd><p>Returns info about a recorded exception.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.exception_set">
<span class="sig-name descname"><span class="pre">exception_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.exception_set" title="Permalink to this definition">#</a></dt>
<dd><p>Records an exception to be raised at the appropriate time.</p>
<p>This also changes the “exception_raise” attribute to point
to the method that will, in fact</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.execute" title="Permalink to this definition">#</a></dt>
<dd><p>Called to execute the task.</p>
<p>This method is called from multiple threads in a parallel build,
so only do thread safe stuff here.  Do thread unsafe stuff in
prepare(), executed() or failed().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.executed">
<span class="sig-name descname"><span class="pre">executed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.executed" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed and
the Taskmaster instance wants to call the Node’s callback
methods.</p>
<p>This may have been a do-nothing operation (to preserve build
order), so we must check the node’s state before deciding whether
it was “built”, in which case we call the appropriate Node method.
In any event, we always call “visited()”, which will handle any
post-visit actions that must take place regardless of whether
or not the target was an actual built target or a source Node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.executed_with_callbacks">
<span class="sig-name descname"><span class="pre">executed_with_callbacks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.executed_with_callbacks" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed and
the Taskmaster instance wants to call the Node’s callback
methods.</p>
<p>This may have been a do-nothing operation (to preserve build
order), so we must check the node’s state before deciding whether
it was “built”, in which case we call the appropriate Node method.
In any event, we always call “visited()”, which will handle any
post-visit actions that must take place regardless of whether
or not the target was an actual built target or a source Node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.executed_without_callbacks">
<span class="sig-name descname"><span class="pre">executed_without_callbacks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.executed_without_callbacks" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed
and the Taskmaster instance doesn’t want to call
the Node’s callback methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.fail_continue">
<span class="sig-name descname"><span class="pre">fail_continue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.fail_continue" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit continue-the-build failure.</p>
<p>This sets failure status on the target nodes and all of
their dependent parent nodes.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.fail_stop">
<span class="sig-name descname"><span class="pre">fail_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.fail_stop" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit stop-the-build failure.</p>
<p>This sets failure status on the target nodes and all of
their dependent parent nodes.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.failed">
<span class="sig-name descname"><span class="pre">failed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.failed" title="Permalink to this definition">#</a></dt>
<dd><p>Default action when a task fails:  stop the build.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.get_target">
<span class="sig-name descname"><span class="pre">get_target</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.get_target" title="Permalink to this definition">#</a></dt>
<dd><p>Fetch the target being built or updated by this task.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.make_ready">
<span class="sig-name descname"><span class="pre">make_ready</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.make_ready" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution if any target
is not current.</p>
<p>This is the default behavior for building only what’s necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.make_ready_all">
<span class="sig-name descname"><span class="pre">make_ready_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.make_ready_all" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution.</p>
<p>This is used when the interface needs every target Node to be
visited–the canonical example being the “scons -c” option.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.make_ready_current">
<span class="sig-name descname"><span class="pre">make_ready_current</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.make_ready_current" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution if any target
is not current.</p>
<p>This is the default behavior for building only what’s necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.needs_execute">
<span class="sig-name descname"><span class="pre">needs_execute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#AlwaysTask.needs_execute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.needs_execute" title="Permalink to this definition">#</a></dt>
<dd><p>Always returns True (indicating this Task should always
be executed).</p>
<p>Subclasses that need this behavior (as opposed to the default
of only executing Nodes that are out of date w.r.t. their
dependencies) can use this as follows:</p>
<blockquote>
<div><dl class="simple">
<dt>class MyTaskSubclass(SCons.Taskmaster.Task):</dt><dd><p>needs_execute = SCons.Taskmaster.AlwaysTask.needs_execute</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.postprocess">
<span class="sig-name descname"><span class="pre">postprocess</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.postprocess" title="Permalink to this definition">#</a></dt>
<dd><p>Post-processes a task after it’s been executed.</p>
<p>This examines all the targets just built (or not, we don’t care
if the build was successful, or even if there was no build
because everything was up-to-date) to see if they have any
waiting parent Nodes, or Nodes waiting on a common side effect,
that can be put back on the candidates list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.prepare" title="Permalink to this definition">#</a></dt>
<dd><p>Called just before the task is executed.</p>
<p>This is mainly intended to give the target Nodes a chance to
unlink underlying files and make all necessary directories before
the Action is actually called to build the targets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.AlwaysTask.trace_message">
<span class="sig-name descname"><span class="pre">trace_message</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'node'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.AlwaysTask.trace_message" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.</span></span><span class="sig-name descname"><span class="pre">OutOfDateTask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#OutOfDateTask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SCons.Taskmaster.Task" title="SCons.Taskmaster.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCons.Taskmaster.Task</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.LOGGER">
<span class="sig-name descname"><span class="pre">LOGGER</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.LOGGER" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask._abc_impl" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask._exception_raise">
<span class="sig-name descname"><span class="pre">_exception_raise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask._exception_raise" title="Permalink to this definition">#</a></dt>
<dd><p>Raises a pending exception that was recorded while getting a
Task ready for execution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask._no_exception_to_raise">
<span class="sig-name descname"><span class="pre">_no_exception_to_raise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask._no_exception_to_raise" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.display">
<span class="sig-name descname"><span class="pre">display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.display" title="Permalink to this definition">#</a></dt>
<dd><p>Hook to allow the calling interface to display a message.</p>
<p>This hook gets called as part of preparing a task for execution
(that is, a Node to be built).  As part of figuring out what Node
should be built next, the actual target list may be altered,
along with a message describing the alteration.  The calling
interface can subclass Task and provide a concrete implementation
of this method to see those messages.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.exc_clear">
<span class="sig-name descname"><span class="pre">exc_clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.exc_clear" title="Permalink to this definition">#</a></dt>
<dd><p>Clears any recorded exception.</p>
<p>This also changes the “exception_raise” attribute to point
to the appropriate do-nothing method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.exc_info">
<span class="sig-name descname"><span class="pre">exc_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.exc_info" title="Permalink to this definition">#</a></dt>
<dd><p>Returns info about a recorded exception.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.exception_set">
<span class="sig-name descname"><span class="pre">exception_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.exception_set" title="Permalink to this definition">#</a></dt>
<dd><p>Records an exception to be raised at the appropriate time.</p>
<p>This also changes the “exception_raise” attribute to point
to the method that will, in fact</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.execute" title="Permalink to this definition">#</a></dt>
<dd><p>Called to execute the task.</p>
<p>This method is called from multiple threads in a parallel build,
so only do thread safe stuff here.  Do thread unsafe stuff in
prepare(), executed() or failed().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.executed">
<span class="sig-name descname"><span class="pre">executed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.executed" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed and
the Taskmaster instance wants to call the Node’s callback
methods.</p>
<p>This may have been a do-nothing operation (to preserve build
order), so we must check the node’s state before deciding whether
it was “built”, in which case we call the appropriate Node method.
In any event, we always call “visited()”, which will handle any
post-visit actions that must take place regardless of whether
or not the target was an actual built target or a source Node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.executed_with_callbacks">
<span class="sig-name descname"><span class="pre">executed_with_callbacks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.executed_with_callbacks" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed and
the Taskmaster instance wants to call the Node’s callback
methods.</p>
<p>This may have been a do-nothing operation (to preserve build
order), so we must check the node’s state before deciding whether
it was “built”, in which case we call the appropriate Node method.
In any event, we always call “visited()”, which will handle any
post-visit actions that must take place regardless of whether
or not the target was an actual built target or a source Node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.executed_without_callbacks">
<span class="sig-name descname"><span class="pre">executed_without_callbacks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.executed_without_callbacks" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed
and the Taskmaster instance doesn’t want to call
the Node’s callback methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.fail_continue">
<span class="sig-name descname"><span class="pre">fail_continue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.fail_continue" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit continue-the-build failure.</p>
<p>This sets failure status on the target nodes and all of
their dependent parent nodes.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.fail_stop">
<span class="sig-name descname"><span class="pre">fail_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.fail_stop" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit stop-the-build failure.</p>
<p>This sets failure status on the target nodes and all of
their dependent parent nodes.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.failed">
<span class="sig-name descname"><span class="pre">failed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.failed" title="Permalink to this definition">#</a></dt>
<dd><p>Default action when a task fails:  stop the build.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.get_target">
<span class="sig-name descname"><span class="pre">get_target</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.get_target" title="Permalink to this definition">#</a></dt>
<dd><p>Fetch the target being built or updated by this task.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.make_ready">
<span class="sig-name descname"><span class="pre">make_ready</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.make_ready" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution if any target
is not current.</p>
<p>This is the default behavior for building only what’s necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.make_ready_all">
<span class="sig-name descname"><span class="pre">make_ready_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.make_ready_all" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution.</p>
<p>This is used when the interface needs every target Node to be
visited–the canonical example being the “scons -c” option.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.make_ready_current">
<span class="sig-name descname"><span class="pre">make_ready_current</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.make_ready_current" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution if any target
is not current.</p>
<p>This is the default behavior for building only what’s necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.needs_execute">
<span class="sig-name descname"><span class="pre">needs_execute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#OutOfDateTask.needs_execute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.needs_execute" title="Permalink to this definition">#</a></dt>
<dd><p>Returns True (indicating this Task should be executed) if this
Task’s target state indicates it needs executing, which has
already been determined by an earlier up-to-date check.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.postprocess">
<span class="sig-name descname"><span class="pre">postprocess</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.postprocess" title="Permalink to this definition">#</a></dt>
<dd><p>Post-processes a task after it’s been executed.</p>
<p>This examines all the targets just built (or not, we don’t care
if the build was successful, or even if there was no build
because everything was up-to-date) to see if they have any
waiting parent Nodes, or Nodes waiting on a common side effect,
that can be put back on the candidates list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.prepare" title="Permalink to this definition">#</a></dt>
<dd><p>Called just before the task is executed.</p>
<p>This is mainly intended to give the target Nodes a chance to
unlink underlying files and make all necessary directories before
the Action is actually called to build the targets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.OutOfDateTask.trace_message">
<span class="sig-name descname"><span class="pre">trace_message</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'node'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.OutOfDateTask.trace_message" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Stats">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.</span></span><span class="sig-name descname"><span class="pre">Stats</span></span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Stats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Stats" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple class for holding statistics about the disposition of a
Node by the Taskmaster.  If we’re collecting statistics, each Node
processed by the Taskmaster gets one of these attached, in which case
the Taskmaster records its decision each time it processes the Node.
(Ideally, that’s just once per Node.)</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.</span></span><span class="sig-name descname"><span class="pre">Task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>SCons build engine abstract task class.</p>
<p>This controls the interaction of the actual building of node
and the rest of the engine.</p>
<p>This is expected to handle all of the normally-customizable
aspects of controlling a build, so any given application
<em>should</em> be able to do what it wants by sub-classing this
class and overriding methods as appropriate.  If an application
needs to customize something by sub-classing Taskmaster (or
some other build engine class), we should first try to migrate
that functionality into this class.</p>
<p>Note that it’s generally a good idea for sub-classes to call
these methods explicitly to update state, etc., rather than
roll their own interaction with Taskmaster from scratch.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.LOGGER">
<span class="sig-name descname"><span class="pre">LOGGER</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#SCons.Taskmaster.Task.LOGGER" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task._abc_impl">
<span class="sig-name descname"><span class="pre">_abc_impl</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_abc._abc_data</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#SCons.Taskmaster.Task._abc_impl" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task._exception_raise">
<span class="sig-name descname"><span class="pre">_exception_raise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task._exception_raise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task._exception_raise" title="Permalink to this definition">#</a></dt>
<dd><p>Raises a pending exception that was recorded while getting a
Task ready for execution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task._no_exception_to_raise">
<span class="sig-name descname"><span class="pre">_no_exception_to_raise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task._no_exception_to_raise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task._no_exception_to_raise" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.display">
<span class="sig-name descname"><span class="pre">display</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.display"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.display" title="Permalink to this definition">#</a></dt>
<dd><p>Hook to allow the calling interface to display a message.</p>
<p>This hook gets called as part of preparing a task for execution
(that is, a Node to be built).  As part of figuring out what Node
should be built next, the actual target list may be altered,
along with a message describing the alteration.  The calling
interface can subclass Task and provide a concrete implementation
of this method to see those messages.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.exc_clear">
<span class="sig-name descname"><span class="pre">exc_clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.exc_clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.exc_clear" title="Permalink to this definition">#</a></dt>
<dd><p>Clears any recorded exception.</p>
<p>This also changes the “exception_raise” attribute to point
to the appropriate do-nothing method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.exc_info">
<span class="sig-name descname"><span class="pre">exc_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.exc_info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.exc_info" title="Permalink to this definition">#</a></dt>
<dd><p>Returns info about a recorded exception.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.exception_set">
<span class="sig-name descname"><span class="pre">exception_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.exception_set"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.exception_set" title="Permalink to this definition">#</a></dt>
<dd><p>Records an exception to be raised at the appropriate time.</p>
<p>This also changes the “exception_raise” attribute to point
to the method that will, in fact</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.execute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.execute" title="Permalink to this definition">#</a></dt>
<dd><p>Called to execute the task.</p>
<p>This method is called from multiple threads in a parallel build,
so only do thread safe stuff here.  Do thread unsafe stuff in
prepare(), executed() or failed().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.executed">
<span class="sig-name descname"><span class="pre">executed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Task.executed" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed and
the Taskmaster instance wants to call the Node’s callback
methods.</p>
<p>This may have been a do-nothing operation (to preserve build
order), so we must check the node’s state before deciding whether
it was “built”, in which case we call the appropriate Node method.
In any event, we always call “visited()”, which will handle any
post-visit actions that must take place regardless of whether
or not the target was an actual built target or a source Node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.executed_with_callbacks">
<span class="sig-name descname"><span class="pre">executed_with_callbacks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.executed_with_callbacks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.executed_with_callbacks" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed and
the Taskmaster instance wants to call the Node’s callback
methods.</p>
<p>This may have been a do-nothing operation (to preserve build
order), so we must check the node’s state before deciding whether
it was “built”, in which case we call the appropriate Node method.
In any event, we always call “visited()”, which will handle any
post-visit actions that must take place regardless of whether
or not the target was an actual built target or a source Node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.executed_without_callbacks">
<span class="sig-name descname"><span class="pre">executed_without_callbacks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.executed_without_callbacks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.executed_without_callbacks" title="Permalink to this definition">#</a></dt>
<dd><p>Called when the task has been successfully executed
and the Taskmaster instance doesn’t want to call
the Node’s callback methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.fail_continue">
<span class="sig-name descname"><span class="pre">fail_continue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.fail_continue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.fail_continue" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit continue-the-build failure.</p>
<p>This sets failure status on the target nodes and all of
their dependent parent nodes.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.fail_stop">
<span class="sig-name descname"><span class="pre">fail_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.fail_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.fail_stop" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit stop-the-build failure.</p>
<p>This sets failure status on the target nodes and all of
their dependent parent nodes.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.failed">
<span class="sig-name descname"><span class="pre">failed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.failed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.failed" title="Permalink to this definition">#</a></dt>
<dd><p>Default action when a task fails:  stop the build.</p>
<p>Note: Although this function is normally invoked on nodes in
the executing state, it might also be invoked on up-to-date
nodes when using Configure().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.get_target">
<span class="sig-name descname"><span class="pre">get_target</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.get_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.get_target" title="Permalink to this definition">#</a></dt>
<dd><p>Fetch the target being built or updated by this task.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.make_ready">
<span class="sig-name descname"><span class="pre">make_ready</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SCons.Taskmaster.Task.make_ready" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution if any target
is not current.</p>
<p>This is the default behavior for building only what’s necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.make_ready_all">
<span class="sig-name descname"><span class="pre">make_ready_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.make_ready_all"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.make_ready_all" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution.</p>
<p>This is used when the interface needs every target Node to be
visited–the canonical example being the “scons -c” option.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.make_ready_current">
<span class="sig-name descname"><span class="pre">make_ready_current</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.make_ready_current"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.make_ready_current" title="Permalink to this definition">#</a></dt>
<dd><p>Marks all targets in a task ready for execution if any target
is not current.</p>
<p>This is the default behavior for building only what’s necessary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.needs_execute">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">needs_execute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.needs_execute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.needs_execute" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.postprocess">
<span class="sig-name descname"><span class="pre">postprocess</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.postprocess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.postprocess" title="Permalink to this definition">#</a></dt>
<dd><p>Post-processes a task after it’s been executed.</p>
<p>This examines all the targets just built (or not, we don’t care
if the build was successful, or even if there was no build
because everything was up-to-date) to see if they have any
waiting parent Nodes, or Nodes waiting on a common side effect,
that can be put back on the candidates list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.prepare" title="Permalink to this definition">#</a></dt>
<dd><p>Called just before the task is executed.</p>
<p>This is mainly intended to give the target Nodes a chance to
unlink underlying files and make all necessary directories before
the Action is actually called to build the targets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Task.trace_message">
<span class="sig-name descname"><span class="pre">trace_message</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'node'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Task.trace_message"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Task.trace_message" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.</span></span><span class="sig-name descname"><span class="pre">Taskmaster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Taskmaster for walking the dependency DAG.</p>
<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster._find_next_ready_node">
<span class="sig-name descname"><span class="pre">_find_next_ready_node</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster._find_next_ready_node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster._find_next_ready_node" title="Permalink to this definition">#</a></dt>
<dd><p>Finds the next node that is ready to be built.</p>
<p>This is <em>the</em> main guts of the DAG walk.  We loop through the
list of candidates, looking for something that has no un-built
children (i.e., that is a leaf Node or has dependencies that are
all leaf Nodes or up-to-date).  Candidate Nodes are re-scanned
(both the target Node itself and its sources, which are always
scanned in the context of a given target) to discover implicit
dependencies.  A Node that must wait for some children to be
built will be put back on the candidates list after the children
have finished building.  A Node that has been put back on the
candidates list in this way may have itself (or its sources)
re-scanned, in order to handle generated header files (e.g.) and
the implicit dependencies therein.</p>
<p>Note that this method does not do any signature calculation or
up-to-date check itself.  All of that is handled by the Task
class.  This is purely concerned with the dependency graph walk.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster._validate_pending_children">
<span class="sig-name descname"><span class="pre">_validate_pending_children</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster._validate_pending_children"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster._validate_pending_children" title="Permalink to this definition">#</a></dt>
<dd><p>Validate the content of the pending_children set. Assert if an
internal error is found.</p>
<p>This function is used strictly for debugging the taskmaster by
checking that no invariants are violated. It is not used in
normal operation.</p>
<p>The pending_children set is used to detect cycles in the
dependency graph. We call a “pending child” a child that is
found in the “pending” state when checking the dependencies of
its parent node.</p>
<p>A pending child can occur when the Taskmaster completes a loop
through a cycle. For example, let’s imagine a graph made of
three nodes (A, B and C) making a cycle. The evaluation starts
at node A. The Taskmaster first considers whether node A’s
child B is up-to-date. Then, recursively, node B needs to
check whether node C is up-to-date. This leaves us with a
dependency graph looking like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                      <span class="n">Next</span> <span class="n">candidate</span>                                                                       <span class="n">Node</span> <span class="n">A</span> <span class="p">(</span><span class="n">Pending</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">Node</span> <span class="n">B</span><span class="p">(</span><span class="n">Pending</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">Node</span> <span class="n">C</span> <span class="p">(</span><span class="n">NoState</span><span class="p">)</span>
<span class="o">^</span>                                     <span class="o">|</span>
<span class="o">|</span>                                     <span class="o">|</span>
<span class="o">+-------------------------------------+</span>
</pre></div>
</div>
<p>Now, when the Taskmaster examines the Node C’s child Node A,
it finds that Node A is in the “pending” state. Therefore,
Node A is a pending child of node C.</p>
<p>Pending children indicate that the Taskmaster has potentially
loop back through a cycle. We say potentially because it could
also occur when a DAG is evaluated in parallel. For example,
consider the following graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Node</span> <span class="n">A</span> <span class="p">(</span><span class="n">Pending</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">Node</span> <span class="n">B</span><span class="p">(</span><span class="n">Pending</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">Node</span> <span class="n">C</span> <span class="p">(</span><span class="n">Pending</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="o">...</span>
        <span class="o">|</span>                                     <span class="o">^</span>
        <span class="o">|</span>                                     <span class="o">|</span>
        <span class="o">+----------&gt;</span> <span class="n">Node</span> <span class="n">D</span> <span class="p">(</span><span class="n">NoState</span><span class="p">)</span> <span class="o">--------+</span>
                          <span class="o">/</span>
          <span class="n">Next</span> <span class="n">candidate</span> <span class="o">/</span>
</pre></div>
</div>
<p>The Taskmaster first evaluates the nodes A, B, and C and
starts building some children of node C. Assuming, that the
maximum parallel level has not been reached, the Taskmaster
will examine Node D. It will find that Node C is a pending
child of Node D.</p>
<p>In summary, evaluating a graph with a cycle will always
involve a pending child at one point. A pending child might
indicate either a cycle or a diamond-shaped DAG. Only a
fraction of the nodes ends-up being a “pending child” of
another node. This keeps the pending_children set small in
practice.</p>
<p>We can differentiate between the two cases if we wait until
the end of the build. At this point, all the pending children
nodes due to a diamond-shaped DAG will have been properly
built (or will have failed to build). But, the pending
children involved in a cycle will still be in the pending
state.</p>
<p>The taskmaster removes nodes from the pending_children set as
soon as a pending_children node moves out of the pending
state. This also helps to keep the pending_children set small.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.cleanup">
<span class="sig-name descname"><span class="pre">cleanup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.cleanup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.cleanup" title="Permalink to this definition">#</a></dt>
<dd><p>Check for dependency cycles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.configure_trace">
<span class="sig-name descname"><span class="pre">configure_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.configure_trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.configure_trace" title="Permalink to this definition">#</a></dt>
<dd><p>This handles the command line option –taskmastertrace=
It can be:
-           : output to stdout
&lt;filename&gt;  : output to a file
False/None  : Do not trace</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.find_next_candidate">
<span class="sig-name descname"><span class="pre">find_next_candidate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.find_next_candidate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.find_next_candidate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the next candidate Node for (potential) evaluation.</p>
<p>The candidate list (really a stack) initially consists of all of
the top-level (command line) targets provided when the Taskmaster
was initialized.  While we walk the DAG, visiting Nodes, all the
children that haven’t finished processing get pushed on to the
candidate list.  Each child can then be popped and examined in
turn for whether <em>their</em> children are all up-to-date, in which
case a Task will be created for their actual evaluation and
potential building.</p>
<p>Here is where we also allow candidate Nodes to alter the list of
Nodes that should be examined.  This is used, for example, when
invoking SCons in a source directory.  A source directory Node can
return its corresponding build directory Node, essentially saying,
“Hey, you really need to build this thing over here instead.”</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.next_task">
<span class="sig-name descname"><span class="pre">next_task</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.next_task"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.next_task" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the next task to be executed.</p>
<p>This simply asks for the next Node to be evaluated, and then wraps
it in the specific Task subclass with which we were initialized.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.no_next_candidate">
<span class="sig-name descname"><span class="pre">no_next_candidate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.no_next_candidate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.no_next_candidate" title="Permalink to this definition">#</a></dt>
<dd><p>Stops Taskmaster processing by not returning a next candidate.</p>
<p>Note that we have to clean-up the Taskmaster candidate list
because the cycle detection depends on the fact all nodes have
been processed somehow.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.stop">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.stop" title="Permalink to this definition">#</a></dt>
<dd><p>Stops the current build completely.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.tm_trace_node">
<span class="sig-name descname"><span class="pre">tm_trace_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.tm_trace_node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.tm_trace_node" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="SCons.Taskmaster.Taskmaster.will_not_build">
<span class="sig-name descname"><span class="pre">will_not_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_func=&lt;function</span> <span class="pre">Taskmaster.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#Taskmaster.will_not_build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.Taskmaster.will_not_build" title="Permalink to this definition">#</a></dt>
<dd><p>Perform clean-up about nodes that will never be built. Invokes
a user defined function on all of these nodes (including all
of their parents).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SCons.Taskmaster.dump_stats">
<span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.</span></span><span class="sig-name descname"><span class="pre">dump_stats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#dump_stats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.dump_stats" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SCons.Taskmaster.find_cycle">
<span class="sig-prename descclassname"><span class="pre">SCons.Taskmaster.</span></span><span class="sig-name descname"><span class="pre">find_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stack</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visited</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SCons/Taskmaster/#find_cycle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#SCons.Taskmaster.find_cycle" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../SCons.Script/" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">SCons.Script package</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../SCons.Tool/" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">SCons.Tool package</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By SCons Project Team<br/>
  
      &copy; Copyright 2022, SCons Project.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>