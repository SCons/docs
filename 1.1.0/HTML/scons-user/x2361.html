<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Command-Line variable=value Build Variables</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="SCons User Guide 1.1.0"
HREF="index.html"><LINK
REL="UP"
TITLE="Controlling a Build From the Command Line"
HREF="c2008.html"><LINK
REL="PREVIOUS"
TITLE="Controlling a Build From the Command Line"
HREF="c2008.html"><LINK
REL="NEXT"
TITLE="Command-Line Targets"
HREF="x2720.html"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SCons User Guide 1.1.0</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c2008.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 12. Controlling a Build From the Command Line</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2720.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="sect-command-line-variables"
>12.2. Command-Line <CODE
CLASS="varname"
>variable</CODE
>=<CODE
CLASS="varname"
>value</CODE
> Build Variables</A
></H1
><P
>&#13;
    You may want to control various aspects
    of your build by allowing the user
    to specify <CODE
CLASS="varname"
>variable</CODE
>=<CODE
CLASS="varname"
>value</CODE
>
    values on the command line.
    For example, suppose you
    want users to be able to
    build a debug version of a program
    by running <SPAN
CLASS="application"
>SCons</SPAN
> as follows:

    </P
><PRE
CLASS="screen"
>&#13;      % <KBD
CLASS="userinput"
>scons -Q debug=1</KBD
>
    </PRE
><P
>&#13;
    <SPAN
CLASS="application"
>SCons</SPAN
> provides an <CODE
CLASS="varname"
>ARGUMENTS</CODE
> dictionary
    that stores all of the
    <CODE
CLASS="varname"
>variable</CODE
>=<CODE
CLASS="varname"
>value</CODE
>
    assignments from the command line.
    This allows you to modify
    aspects of your build in response
    to specifications on the command line.
    (Note that unless you want to require
    that users <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>always</I
></SPAN
>
    specify a variable,
    you probably want to use
    the Python
    <TT
CLASS="literal"
>ARGUMENTS.get()</TT
> function,
    which allows you to specify a default value
    to be used if there is no specification
    on the command line.)

    </P
><P
>&#13;
    The following code sets the <A
HREF="a4761.html#cv-CCFLAGS"
><CODE
CLASS="envar"
>$CCFLAGS</CODE
></A
> construction
    variable in response to the <CODE
CLASS="varname"
>debug</CODE
>
    flag being set in the <CODE
CLASS="varname"
>ARGUMENTS</CODE
> dictionary:

    </P
><PRE
CLASS="programlisting"
>&#13;       env = Environment()
       debug = ARGUMENTS.get('debug', 0)
       if int(debug):
           env.Append(CCFLAGS = '-g')
       env.Program('prog.c')
    </PRE
><P
>&#13;
    This results in the <CODE
CLASS="varname"
>-g</CODE
>
    compiler option being used when
    <TT
CLASS="literal"
>debug=1</TT
>
    is used on the command line:

    </P
><PRE
CLASS="screen"
>&#13;       % <KBD
CLASS="userinput"
>scons -Q debug=0</KBD
>
       cc -o prog.o -c prog.c
       cc -o prog prog.o
       % <KBD
CLASS="userinput"
>scons -Q debug=0</KBD
>
       scons: `.' is up to date.
       % <KBD
CLASS="userinput"
>scons -Q debug=1</KBD
>
       cc -o prog.o -c -g prog.c
       cc -o prog prog.o
       % <KBD
CLASS="userinput"
>scons -Q debug=1</KBD
>
       scons: `.' is up to date.
    </PRE
><P
>&#13;
    Notice that <SPAN
CLASS="application"
>SCons</SPAN
> keeps track of
    the last values used to build the object files,
    and as a result correctly rebuilds
    the object and executable files
    only when the value of the <TT
CLASS="literal"
>debug</TT
>
    argument has changed.

    </P
><P
>&#13;
    The <CODE
CLASS="varname"
>ARGUMENTS</CODE
> dictionary has two minor drawbacks.
    First, because it is a dictionary,
    it can only store one value for each specified keyword,
    and thus only "remembers" the last setting
    for each keyword on the command line.
    This makes the <CODE
CLASS="varname"
>ARGUMENTS</CODE
> dictionary
    inappropriate if users should be able to
    specify multiple values
    on the command line for a given keyword.
    Second, it does not preserve
    the order in which the variable settings
    were specified,
    which is a problem if
    you want the configuration to
    behave differently in response
    to the order in which the build
    variable settings were specified on the command line.

    </P
><P
>&#13;
    To accomodate these requirements,
    <SPAN
CLASS="application"
>SCons</SPAN
> provides an <CODE
CLASS="varname"
>ARGLIST</CODE
> variable
    that gives you direct access to
    <CODE
CLASS="varname"
>variable</CODE
>=<CODE
CLASS="varname"
>value</CODE
>
    settings on the command line,
    in the exact order they were specified,
    and without removing any duplicate settings.
    Each element in the <CODE
CLASS="varname"
>ARGLIST</CODE
> variable
    is itself a two-element list
    containing the keyword and the value
    of the setting,
    and you must loop through,
    or otherwise select from,
    the elements of <CODE
CLASS="varname"
>ARGLIST</CODE
> to
    process the specific settings you want
    in whatever way is appropriate for your configuration.
    For example,
    the following code to let the user
    add to the <CODE
CLASS="varname"
>CPPDEFINES</CODE
> construction variable
    by specifying multiple
    <CODE
CLASS="varname"
>define=</CODE
>
    settings on the command line:

    </P
><PRE
CLASS="programlisting"
>&#13;       cppdefines = []
       for key, value in ARGLIST:
           if key == 'define':
               cppdefines.append(value)
       env = Environment(CPPDEFINES = cppdefines)
       env.Object('prog.c')
    </PRE
><P
>&#13;
    Yields the followig output:

    </P
><PRE
CLASS="screen"
>&#13;       % <KBD
CLASS="userinput"
>scons -Q define=FOO</KBD
>
       cc -o prog.o -c -DFOO prog.c
       % <KBD
CLASS="userinput"
>scons -Q define=FOO define=BAR</KBD
>
       cc -o prog.o -c -DFOO -DBAR prog.c
    </PRE
><P
>&#13;
    Note that the <CODE
CLASS="varname"
>ARGLIST</CODE
> and <CODE
CLASS="varname"
>ARGUMENTS</CODE
>
    variables do not interfere with each other,
    but merely provide slightly different views
    into how the user specified
    <CODE
CLASS="varname"
>variable</CODE
>=<CODE
CLASS="varname"
>value</CODE
>
    settings on the command line.
    You can use both variables in the same
    <SPAN
CLASS="application"
>SCons</SPAN
> configuration.
    In general, the <CODE
CLASS="varname"
>ARGUMENTS</CODE
> dictionary
    is more convenient to use,
    (since you can just fetch variable
    settings through a dictionary access),
    and the <CODE
CLASS="varname"
>ARGLIST</CODE
> list
    is more flexible
    (since you can examine the
    specific order in which
    the user's command-line variabe settings).

    </P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN2420"
>12.2.1. Controlling Command-Line Build Variables</A
></H2
><P
>&#13;
      Being able to use a command-line build variable like
      <TT
CLASS="literal"
>debug=1</TT
> is handy,
      but it can be a chore to write specific Python code
      to recognize each such variable,
      check for errors and provide appropriate messages,
      and apply the values to a construction variable.
      To help with this,
      <SPAN
CLASS="application"
>SCons</SPAN
> supports a class to
      define such build variables easily,
      and a mechanism to apply the
      build variables to a construction environment.
      This allows you to control how the build variables affect
      construction environments.

      </P
><P
>&#13;
      For example, suppose that you want users to set
      a <CODE
CLASS="varname"
>RELEASE</CODE
> construction variable on the
      command line whenever the time comes to build
      a program for release,
      and that the value of this variable
      should be added to the command line
      with the appropriate <TT
CLASS="literal"
>-D</TT
> option
      (or other command line option)
      to pass the value to the C compiler.
      Here's how you might do that by setting
      the appropriate value in a dictionary for the
      <A
HREF="a4761.html#cv-CPPDEFINES"
><CODE
CLASS="envar"
>$CPPDEFINES</CODE
></A
> construction variable:

      </P
><PRE
CLASS="programlisting"
>&#13;           vars = Variables()
           vars.Add('RELEASE', 'Set to 1 to build for release', 0)
           env = Environment(variables = vars,
                             CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
           env.Program(['foo.c', 'bar.c'])
      </PRE
><P
>&#13;
      This <TT
CLASS="filename"
>SConstruct</TT
> file first creates a <CODE
CLASS="function"
>Variables</CODE
> object
      (the <TT
CLASS="literal"
>vars = Variables()</TT
> call),
      and then uses the object's <CODE
CLASS="function"
>Add</CODE
>
      method to indicate that the <CODE
CLASS="varname"
>RELEASE</CODE
>
      variable can be set on the command line,
      and that its default value will be <TT
CLASS="literal"
>0</TT
>
      (the third argument to the <CODE
CLASS="function"
>Add</CODE
> method).
      The second argument is a line of help text;
      we'll learn how to use it in the next section.

      </P
><P
>&#13;
      We then pass the created <CODE
CLASS="function"
>Variables</CODE
>
      object as a <CODE
CLASS="varname"
>variables</CODE
> keyword argument
      to the <CODE
CLASS="function"
>Environment</CODE
> call
      used to create the construction environment.
      This then allows a user to set the
      <CODE
CLASS="varname"
>RELEASE</CODE
> build variable on the command line
      and have the variable show up in
      the command line used to build each object from
      a C source file:

      </P
><PRE
CLASS="screen"
>&#13;        % <KBD
CLASS="userinput"
>scons -Q RELEASE=1</KBD
>
        cc -o bar.o -c -DRELEASE_BUILD=1 bar.c
        cc -o foo.o -c -DRELEASE_BUILD=1 foo.c
        cc -o foo foo.o bar.o
      </PRE
><P
>&#13;
      NOTE:  Before <SPAN
CLASS="application"
>SCons</SPAN
> release 0.98.1, these build variables
      were known as "command-line build options."
      The class was actually named the <CODE
CLASS="function"
>Options</CODE
> class,
      and in the sections below,
      the various functions were named
      <CODE
CLASS="function"
>BoolOption</CODE
>, <CODE
CLASS="function"
>EnumOption</CODE
>, <CODE
CLASS="function"
>ListOption</CODE
>,
      <CODE
CLASS="function"
>PathOption</CODE
>, <CODE
CLASS="function"
>PackageOption</CODE
> and <CODE
CLASS="function"
>AddOptions</CODE
>.
      These older names still work,
      and you may encounter them in older
      <TT
CLASS="filename"
>SConscript</TT
> fles,
      but their use is discouraged
      and will be officially deprecated some day.

      </P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN2456"
>12.2.2. Providing Help for Command-Line Build Variables</A
></H2
><P
>&#13;
      To make command-line build variables most useful,
      you ideally want to provide
      some help text that will describe
      the available variables
      when the user runs <TT
CLASS="literal"
>scons -h</TT
>.
      You could write this text by hand,
      but <SPAN
CLASS="application"
>SCons</SPAN
> provides an easier way.
      <CODE
CLASS="function"
>Variables</CODE
> objects support a
      <CODE
CLASS="function"
>GenerateHelpText</CODE
> method
      that will, as its name suggests,
      generate text that describes
      the various variables that
      have been added to it.
      You then pass the output from this method to
      the <CODE
CLASS="function"
>Help</CODE
> function:

      </P
><PRE
CLASS="programlisting"
>&#13;           vars = Variables('custom.py')
           vars.Add('RELEASE', 'Set to 1 to build for release', 0)
           env = Environment(variables = vars)
           Help(vars.GenerateHelpText(env))
      </PRE
><P
>&#13;
      <SPAN
CLASS="application"
>SCons</SPAN
> will now display some useful text
      when the <TT
CLASS="literal"
>-h</TT
> option is used:

      </P
><PRE
CLASS="screen"
>&#13;        % <KBD
CLASS="userinput"
>scons -Q -h</KBD
>
        
        RELEASE: Set to 1 to build for release
            default: 0
            actual: 0
        
        Use scons -H for help about command-line options.
      </PRE
><P
>&#13;
      Notice that the help output shows the default value,
      and the current actual value of the build variable.

      </P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN2471"
>12.2.3. Reading Build Variables From a File</A
></H2
><P
>&#13;
      Giving the user a way to specify the
      value of a build variable on the command line
      is useful,
      but can still be tedious
      if users must specify the variable
      every time they run <SPAN
CLASS="application"
>SCons</SPAN
>.
      We can let users provide customized build variable settings
      in a local file by providing a
      file name when we create the
      <CODE
CLASS="function"
>Variables</CODE
> object:

      </P
><PRE
CLASS="programlisting"
>&#13;           vars = Variables('custom.py')
           vars.Add('RELEASE', 'Set to 1 to build for release', 0)
           env = Environment(variables = vars,
                             CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
           env.Program(['foo.c', 'bar.c'])
           Help(vars.GenerateHelpText(env))
      </PRE
><P
>&#13;
      This then allows the user to control the <CODE
CLASS="varname"
>RELEASE</CODE
>
      variable by setting it in the <TT
CLASS="filename"
>custom.py</TT
> file:

      </P
><PRE
CLASS="programlisting"
>&#13;        RELEASE = 1
        </PRE
><P
>&#13;
      Note that this file is actually executed
      like a Python script.
      Now when we run <SPAN
CLASS="application"
>SCons</SPAN
>:

      </P
><PRE
CLASS="screen"
>&#13;        % <KBD
CLASS="userinput"
>scons -Q</KBD
>
        cc -o bar.o -c -DRELEASE_BUILD=1 bar.c
        cc -o foo.o -c -DRELEASE_BUILD=1 foo.c
        cc -o foo foo.o bar.o
      </PRE
><P
>&#13;
      And if we change the contents of <TT
CLASS="filename"
>custom.py</TT
> to:

      </P
><PRE
CLASS="programlisting"
>&#13;        RELEASE = 0
      </PRE
><P
>&#13;
      The object files are rebuilt appropriately
      with the new variable:

      </P
><PRE
CLASS="screen"
>&#13;        % <KBD
CLASS="userinput"
>scons -Q</KBD
>
        cc -o bar.o -c -DRELEASE_BUILD=0 bar.c
        cc -o foo.o -c -DRELEASE_BUILD=0 foo.c
        cc -o foo foo.o bar.o
      </PRE
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN2491"
>12.2.4. Pre-Defined Build Variable Functions</A
></H2
><P
>&#13;
      <SPAN
CLASS="application"
>SCons</SPAN
> provides a number of functions
      that provide ready-made behaviors
      for various types of command-line build variables.

      </P
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN2495"
>12.2.4.1. True/False Values:  the <CODE
CLASS="function"
>BoolVariable</CODE
> Build Variable Function</A
></H3
><P
>&#13;
        It's often handy to be able to specify a
        variable that controls a simple Boolean variable
        with a <TT
CLASS="literal"
>true</TT
> or <TT
CLASS="literal"
>false</TT
> value.
        It would be even more handy to accomodate
        users who have different preferences for how to represent
        <TT
CLASS="literal"
>true</TT
> or <TT
CLASS="literal"
>false</TT
> values.
        The <CODE
CLASS="function"
>BoolVariable</CODE
> function
        makes it easy to accomodate these
        common representations of
        <TT
CLASS="literal"
>true</TT
> or <TT
CLASS="literal"
>false</TT
>.

        </P
><P
>&#13;
        The <CODE
CLASS="function"
>BoolVariable</CODE
> function takes three arguments:
        the name of the build variable,
        the default value of the build variable,
        and the help string for the variable.
        It then returns appropriate information for
        passing to the <CODE
CLASS="function"
>Add</CODE
> method of a <CODE
CLASS="function"
>Variables</CODE
> object, like so:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(BoolVariable('RELEASE', 'Set to build for release', 0))
             env = Environment(variables = vars,
                               CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        With this build variable,
        the <CODE
CLASS="varname"
>RELEASE</CODE
> variable can now be enabled by
        setting it to the value <TT
CLASS="literal"
>yes</TT
>
        or <TT
CLASS="literal"
>t</TT
>:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q RELEASE=yes foo.o</KBD
>
          cc -o foo.o -c -DRELEASE_BUILD=True foo.c
        </PRE
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q RELEASE=t foo.o</KBD
>
          cc -o foo.o -c -DRELEASE_BUILD=True foo.c
        </PRE
><P
>&#13;
        Other values that equate to <TT
CLASS="literal"
>true</TT
> include
        <TT
CLASS="literal"
>y</TT
>,
        <TT
CLASS="literal"
>1</TT
>,
        <TT
CLASS="literal"
>on</TT
>
        and
        <TT
CLASS="literal"
>all</TT
>.

        </P
><P
>&#13;
        Conversely, <CODE
CLASS="varname"
>RELEASE</CODE
> may now be given a <TT
CLASS="literal"
>false</TT
>
        value by setting it to
        <TT
CLASS="literal"
>no</TT
>
        or
        <TT
CLASS="literal"
>f</TT
>:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q RELEASE=no foo.o</KBD
>
          cc -o foo.o -c -DRELEASE_BUILD=False foo.c
        </PRE
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q RELEASE=f foo.o</KBD
>
          cc -o foo.o -c -DRELEASE_BUILD=False foo.c
        </PRE
><P
>&#13;
        Other values that equate to <TT
CLASS="literal"
>false</TT
> include
        <TT
CLASS="literal"
>n</TT
>,
        <TT
CLASS="literal"
>0</TT
>,
        <TT
CLASS="literal"
>off</TT
>
        and
        <TT
CLASS="literal"
>none</TT
>.

        </P
><P
>&#13;
        Lastly, if a user tries to specify
        any other value,
        <SPAN
CLASS="application"
>SCons</SPAN
> supplies an appropriate error message:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q RELEASE=bad_value foo.o</KBD
>
          
          scons: *** Error converting option: RELEASE
          Invalid value for boolean option: bad_value
          File "/home/my/project/SConstruct", line 4, in &#60;module&#62;
        </PRE
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN2544"
>12.2.4.2. Single Value From a List:  the <CODE
CLASS="function"
>EnumVariable</CODE
> Build Variable Function</A
></H3
><P
>&#13;
        Suppose that we want a user to be able to
        set a <CODE
CLASS="varname"
>COLOR</CODE
> variable
        that selects a background color to be
        displayed by an application,
        but that we want to restrict the
        choices to a specific set of allowed colors.
        This can be set up quite easily
        using the <CODE
CLASS="function"
>EnumVariable</CODE
>,
        which takes a list of <CODE
CLASS="varname"
>allowed_values</CODE
>        in addition to the variable name,
        default value,
        and help text arguments:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(EnumVariable('COLOR', 'Set background color', 'red',
                                 allowed_values=('red', 'green', 'blue')))
             env = Environment(variables = vars,
                               CPPDEFINES={'COLOR' : '"${COLOR}"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        The user can now explicity set the <CODE
CLASS="varname"
>COLOR</CODE
> build variable
        to any of the specified allowed values:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLOR=red foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="red" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLOR=blue foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="blue" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLOR=green foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="green" foo.c
        </PRE
><P
>&#13;
        But, almost more importantly,
        an attempt to set <CODE
CLASS="varname"
>COLOR</CODE
>
        to a value that's not in the list
        generates an error message:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLOR=magenta foo.o</KBD
>
          
          scons: *** Invalid value for option COLOR: magenta
          File "/home/my/project/SConstruct", line 5, in &#60;module&#62;
        </PRE
><P
>&#13;
        The <CODE
CLASS="function"
>EnumVariable</CODE
> function also supports a way
        to map alternate names to allowed values.
        Suppose, for example,
        that we want to allow the user
        to use the word <TT
CLASS="literal"
>navy</TT
> as a synonym for
        <TT
CLASS="literal"
>blue</TT
>.
        We do this by adding a <CODE
CLASS="varname"
>map</CODE
> dictionary
        that will map its key values
        to the desired legal value:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(EnumVariable('COLOR', 'Set background color', 'red',
                                 allowed_values=('red', 'green', 'blue'),
                                 map={'navy':'blue'}))
             env = Environment(variables = vars,
                               CPPDEFINES={'COLOR' : '"${COLOR}"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        As desired, the user can then use
        <TT
CLASS="literal"
>navy</TT
> on the command line,
        and <SPAN
CLASS="application"
>SCons</SPAN
> will translate it into <TT
CLASS="literal"
>blue</TT
>
        when it comes time to use the <CODE
CLASS="varname"
>COLOR</CODE
>
        variable to build a target:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLOR=navy foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="blue" foo.c
        </PRE
><P
>&#13;
        By default, when using the <CODE
CLASS="function"
>EnumVariable</CODE
> function,
        arguments that differ
        from the legal values
        only in case
        are treated as illegal values:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLOR=Red foo.o</KBD
>
          
          scons: *** Invalid value for option COLOR: Red
          File "/home/my/project/SConstruct", line 5, in &#60;module&#62;
          % <KBD
CLASS="userinput"
>scons -Q COLOR=BLUE foo.o</KBD
>
          
          scons: *** Invalid value for option COLOR: BLUE
          File "/home/my/project/SConstruct", line 5, in &#60;module&#62;
          % <KBD
CLASS="userinput"
>scons -Q COLOR=nAvY foo.o</KBD
>
          
          scons: *** Invalid value for option COLOR: nAvY
          File "/home/my/project/SConstruct", line 5, in &#60;module&#62;
        </PRE
><P
>&#13;
        The <CODE
CLASS="function"
>EnumVariable</CODE
> function can take an additional
        <CODE
CLASS="varname"
>ignorecase</CODE
> keyword argument that,
        when set to <TT
CLASS="literal"
>1</TT
>,
        tells <SPAN
CLASS="application"
>SCons</SPAN
> to allow case differences
        when the values are specified:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(EnumVariable('COLOR', 'Set background color', 'red',
                                 allowed_values=('red', 'green', 'blue'),
                                 map={'navy':'blue'},
                                 ignorecase=1))
             env = Environment(variables = vars,
                               CPPDEFINES={'COLOR' : '"${COLOR}"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        Which yields the output:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLOR=Red foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="Red" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLOR=BLUE foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="BLUE" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLOR=nAvY foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="blue" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLOR=green foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="green" foo.c
        </PRE
><P
>&#13;
        Notice that an <CODE
CLASS="varname"
>ignorecase</CODE
> value of <TT
CLASS="literal"
>1</TT
>
        preserves the case-spelling that the user supplied.
        If you want <SPAN
CLASS="application"
>SCons</SPAN
> to translate the names
        into lower-case,
        regardless of the case used by the user,
        specify an <CODE
CLASS="varname"
>ignorecase</CODE
> value of <TT
CLASS="literal"
>2</TT
>:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(EnumVariable('COLOR', 'Set background color', 'red',
                                 allowed_values=('red', 'green', 'blue'),
                                 map={'navy':'blue'},
                                 ignorecase=2))
             env = Environment(variables = vars,
                               CPPDEFINES={'COLOR' : '"${COLOR}"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        Now <SPAN
CLASS="application"
>SCons</SPAN
> will use values of
        <TT
CLASS="literal"
>red</TT
>,
        <TT
CLASS="literal"
>green</TT
> or
        <TT
CLASS="literal"
>blue</TT
>
        regardless of how the user spells
        those values on the command line:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLOR=Red foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="red" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLOR=nAvY foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="blue" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLOR=GREEN foo.o</KBD
>
          cc -o foo.o -c -DCOLOR="green" foo.c
        </PRE
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN2609"
>12.2.4.3. Multiple Values From a List:  the <CODE
CLASS="function"
>ListVariable</CODE
> Build Variable Function</A
></H3
><P
>&#13;
        Another way in which you might want to allow users
        to control a build variable is to
        specify a list of one or more legal values.
        <SPAN
CLASS="application"
>SCons</SPAN
> supports this through the <CODE
CLASS="function"
>ListVariable</CODE
> function.
        If, for example, we want a user to be able to set a
        <CODE
CLASS="varname"
>COLORS</CODE
> variable to one or more of the legal list of values:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(ListVariable('COLORS', 'List of colors', 0,
                                 ['red', 'green', 'blue']))
             env = Environment(variables = vars,
                               CPPDEFINES={'COLORS' : '"${COLORS}"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        A user can now specify a comma-separated list
        of legal values,
        which will get translated into a space-separated
        list for passing to the any build commands:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLORS=red,blue foo.o</KBD
>
          cc -o foo.o -c -DCOLORS="red blue" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLORS=blue,green,red foo.o</KBD
>
          cc -o foo.o -c -DCOLORS="blue green red" foo.c
        </PRE
><P
>&#13;
        In addition, the <CODE
CLASS="function"
>ListVariable</CODE
> function
        allows the user to specify explicit keywords of
        <TT
CLASS="literal"
>all</TT
> or <TT
CLASS="literal"
>none</TT
>
        to select all of the legal values,
        or none of them, respectively:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLORS=all foo.o</KBD
>
          cc -o foo.o -c -DCOLORS="red green blue" foo.c
          % <KBD
CLASS="userinput"
>scons -Q COLORS=none foo.o</KBD
>
          cc -o foo.o -c -DCOLORS="" foo.c
        </PRE
><P
>&#13;
        And, of course, an illegal value
        still generates an error message:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q COLORS=magenta foo.o</KBD
>
          
          scons: *** Error converting option: COLORS
          Invalid value(s) for option: magenta
          File "/home/my/project/SConstruct", line 5, in &#60;module&#62;
        </PRE
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN2631"
>12.2.4.4. Path Names:  the <CODE
CLASS="function"
>PathVariable</CODE
> Build Variable Function</A
></H3
><P
>&#13;
        <SPAN
CLASS="application"
>SCons</SPAN
> supports a <CODE
CLASS="function"
>PathVariable</CODE
> function
        to make it easy to create a build variable
        to control an expected path name.
        If, for example, you need to
        define a variable in the preprocessor
        that controls the location of a
        configuration file:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(PathVariable('CONFIG',
                                 'Path to configuration file',
                                 '/etc/my_config'))
             env = Environment(variables = vars,
                               CPPDEFINES={'CONFIG_FILE' : '"$CONFIG"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        This then allows the user to
        override the <CODE
CLASS="varname"
>CONFIG</CODE
> build variable
        on the command line as necessary:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q foo.o</KBD
>
          cc -o foo.o -c -DCONFIG_FILE="/etc/my_config" foo.c
          % <KBD
CLASS="userinput"
>scons -Q CONFIG=/usr/local/etc/other_config foo.o</KBD
>
          scons: `foo.o' is up to date.
        </PRE
><P
>&#13;
        By default, <CODE
CLASS="function"
>PathVariable</CODE
> checks to make sure
        that the specified path exists and generates an error if it
        doesn't:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q CONFIG=/does/not/exist foo.o</KBD
>
          
          scons: *** Path for option CONFIG does not exist: /does/not/exist
          File "/home/my/project/SConstruct", line 6, in &#60;module&#62;
        </PRE
><P
>&#13;
        <CODE
CLASS="function"
>PathVariable</CODE
> provides a number of methods
        that you can use to change this behavior.
        If you want to ensure that any specified paths are,
        in fact, files and not directories,
        use the <CODE
CLASS="function"
>PathVariable.PathIsFile</CODE
> method:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(PathVariable('CONFIG',
                                 'Path to configuration file',
                                 '/etc/my_config',
                                 PathVariable.PathIsFile))
             env = Environment(variables = vars,
                               CPPDEFINES={'CONFIG_FILE' : '"$CONFIG"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        Conversely, to ensure that any specified paths are
        directories and not files,
        use the <CODE
CLASS="function"
>PathVariable.PathIsDir</CODE
> method:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(PathVariable('DBDIR',
                                 'Path to database directory',
                                 '/var/my_dbdir',
                                 PathVariable.PathIsDir))
             env = Environment(variables = vars,
                               CPPDEFINES={'DBDIR' : '"$DBDIR"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        If you want to make sure that any specified paths
        are directories,
        and you would like the directory created
        if it doesn't already exist,
        use the <CODE
CLASS="function"
>PathVariable.PathIsDirCreate</CODE
> method:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(PathVariable('DBDIR',
                                 'Path to database directory',
                                 '/var/my_dbdir',
                                 PathVariable.PathIsDirCreate))
             env = Environment(variables = vars,
                               CPPDEFINES={'DBDIR' : '"$DBDIR"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        Lastly, if you don't care whether the path exists,
        is a file, or a directory,
        use the <CODE
CLASS="function"
>PathVariable.PathAccept</CODE
> method
        to accept any path that the user supplies:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(PathVariable('OUTPUT',
                                 'Path to output file or directory',
                                 None,
                                 PathVariable.PathAccept))
             env = Environment(variables = vars,
                               CPPDEFINES={'OUTPUT' : '"$OUTPUT"'})
             env.Program('foo.c')
        </PRE
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN2660"
>12.2.4.5. Enabled/Disabled Path Names: the <CODE
CLASS="function"
>PackageVariable</CODE
> Build Variable Function</A
></H3
><P
>&#13;
        Sometimes you want to give users
        even more control over a path name variable,
        allowing them to explicitly enable or
        disable the path name
        by using <TT
CLASS="literal"
>yes</TT
> or <TT
CLASS="literal"
>no</TT
> keywords,
        in addition to allow them
        to supply an explicit path name.
        <SPAN
CLASS="application"
>SCons</SPAN
> supports the <CODE
CLASS="function"
>PackageVariable</CODE
>
        function to support this:

        </P
><PRE
CLASS="programlisting"
>&#13;             vars = Variables('custom.py')
             vars.Add(PackageVariable('PACKAGE',
                                    'Location package',
                                    '/opt/location'))
             env = Environment(variables = vars,
                               CPPDEFINES={'PACKAGE' : '"$PACKAGE"'})
             env.Program('foo.c')
        </PRE
><P
>&#13;
        When the <TT
CLASS="filename"
>SConscript</TT
> file uses the <CODE
CLASS="function"
>PackageVariable</CODE
> funciton,
        user can now still use the default
        or supply an overriding path name,
        but can now explicitly set the
        specified variable to a value
        that indicates the package should be enabled
        (in which case the default should be used)
        or disabled:

        </P
><PRE
CLASS="screen"
>&#13;          % <KBD
CLASS="userinput"
>scons -Q foo.o</KBD
>
          cc -o foo.o -c -DPACKAGE="/opt/location" foo.c
          % <KBD
CLASS="userinput"
>scons -Q PACKAGE=/usr/local/location foo.o</KBD
>
          cc -o foo.o -c -DPACKAGE="/usr/local/location" foo.c
          % <KBD
CLASS="userinput"
>scons -Q PACKAGE=yes foo.o</KBD
>
          cc -o foo.o -c -DPACKAGE="True" foo.c
          % <KBD
CLASS="userinput"
>scons -Q PACKAGE=no foo.o</KBD
>
          cc -o foo.o -c -DPACKAGE="False" foo.c
        </PRE
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN2677"
>12.2.5. Adding Multiple Command-Line Build Variables at Once</A
></H2
><P
>&#13;
      Lastly, <SPAN
CLASS="application"
>SCons</SPAN
> provides a way to add
      multiple build variables to a <CODE
CLASS="function"
>Variables</CODE
> object at once.
      Instead of having to call the <CODE
CLASS="function"
>Add</CODE
> method
      multiple times,
      you can call the <CODE
CLASS="function"
>AddVariables</CODE
>
      method with a list of build variables
      to be added to the object.
      Each build variable is specified
      as either a tuple of arguments,
      just like you'd pass to the <CODE
CLASS="function"
>Add</CODE
> method itself,
      or as a call to one of the pre-defined
      functions for pre-packaged command-line build variables.
      in any order:

      </P
><PRE
CLASS="programlisting"
>&#13;          vars = Variables()
          vars.AddVariables(
              ('RELEASE', 'Set to 1 to build for release', 0),
              ('CONFIG', 'Configuration file', '/etc/my_config'),
              BoolVariable('warnings', 'compilation with -Wall and similiar', 1),
              EnumVariable('debug', 'debug output and symbols', 'no',
                         allowed_values=('yes', 'no', 'full'),
                         map={}, ignorecase=0),  # case sensitive
              ListVariable('shared',
                         'libraries to build as shared libraries',
                         'all',
                         names = list_of_libs),
              PackageVariable('x11',
                            'use X11 installed here (yes = search some places)',
                            'yes'),
              PathVariable('qtdir', 'where the root of Qt is installed', qtdir),
          )
      </PRE
><P
>&#13;      </P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN2687"
>12.2.6. Handling Unknown Command-Line Build Variables:  the <CODE
CLASS="function"
>UnknownVariables</CODE
> Function</A
></H2
><P
>&#13;
      Users may, of course,
      occasionally misspell variable names in their command-line settings.
      <SPAN
CLASS="application"
>SCons</SPAN
> does not generate an error or warning
      for any unknown variables the users specifies on the command line.
      (This is in no small part because you may be
      processing the arguments directly using the <CODE
CLASS="varname"
>ARGUMENTS</CODE
> dictionary,
      and therefore <SPAN
CLASS="application"
>SCons</SPAN
> can't know in the general case
      whether a given "misspelled" variable is
      really unknown and a potential problem,
      or something that your <TT
CLASS="filename"
>SConscript</TT
> file
      will handle directly with some Python code.)

      </P
><P
>&#13;
      If, however, you're using a <CODE
CLASS="function"
>Variables</CODE
> object to
      define a specific set of command-line build variables
      that you expect users to be able to set,
      you may want to provide an error
      message or warning of your own
      if the user supplies a variable setting
      that is <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>not</I
></SPAN
> among
      the defined list of variable names known to the <CODE
CLASS="function"
>Variables</CODE
> object.
      You can do this by calling the <CODE
CLASS="function"
>UnknownVariables</CODE
>
      method of the <CODE
CLASS="function"
>Variables</CODE
> object:

      </P
><PRE
CLASS="programlisting"
>&#13;           vars = Variables(None)
           vars.Add('RELEASE', 'Set to 1 to build for release', 0)
           env = Environment(variables = vars,
                             CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
           unknown = vars.UnknownVariables()
           if unknown:
               print "Unknown variables:", unknown.keys()
               Exit(1)
           env.Program('foo.c')
      </PRE
><P
>&#13;
      The <CODE
CLASS="function"
>UnknownVariables</CODE
> method returns a dictionary
      containing the keywords and values
      of any variables the user specified on the command line
      that are <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>not</I
></SPAN
>
      among the variables known to the <CODE
CLASS="function"
>Variables</CODE
> object
      (from having been specified using
      the <CODE
CLASS="function"
>Variables</CODE
> object's<CODE
CLASS="function"
>Add</CODE
> method).
      In the examble above,
      we check for whether the dictionary
      returned by the <CODE
CLASS="function"
>UnknownVariables</CODE
> is non-empty,
      and if so print the Python list
      containing the names of the unknwown variables
      and then call the <CODE
CLASS="function"
>Exit</CODE
> function
      to terminate <SPAN
CLASS="application"
>SCons</SPAN
>:

      </P
><PRE
CLASS="screen"
>&#13;        % <KBD
CLASS="userinput"
>scons -Q NOT_KNOWN=foo</KBD
>
        Unknown variables: ['NOT_KNOWN']
      </PRE
><P
>&#13;
      Of course, you can process the items in the
      dictionary returned by the <CODE
CLASS="function"
>UnknownVariables</CODE
> function
      in any way appropriate to your bulid configuration,
      including just printing a warning message
      but not exiting,
      logging an error somewhere,
      etc.

      </P
><P
>&#13;
      Note that you must delay the call of <CODE
CLASS="function"
>UnknownVariables</CODE
>
      until after you have applied the <CODE
CLASS="function"
>Variables</CODE
> object
      to a construction environment
      with the <TT
CLASS="literal"
>variables=</TT
>
      keyword argument of an <CODE
CLASS="function"
>Environment</CODE
> call.

      </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c2008.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2720.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Controlling a Build From the Command Line</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2008.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Command-Line Targets</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>