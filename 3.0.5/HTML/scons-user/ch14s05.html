<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>14.5. Sharing Environments (and Other Variables) Between SConscript Files</title><link rel="stylesheet" type="text/css" href="scons.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="SCons 3.0.5"><link rel="up" href="ch14.html" title="Chapter 14. Hierarchical Builds"><link rel="prev" href="ch14s04.html" title="14.4. Absolute Path Names"><link rel="next" href="ch15.html" title="Chapter 15. Separating Source and Build Directories"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">14.5. Sharing Environments (and Other Variables) Between <code class="filename">SConscript</code> Files</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch14s04.html">Prev</a> </td><th width="60%" align="center">Chapter 14. Hierarchical Builds</th><td width="20%" align="right"> <a accesskey="n" href="ch15.html">Next</a></td></tr></table><hr></div><div class="section" title="14.5. Sharing Environments (and Other Variables) Between SConscript Files"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm3306"></a>14.5. Sharing Environments (and Other Variables) Between <code class="filename">SConscript</code> Files</h2></div></div></div><p>

    In the previous example,
    each of the subsidiary <code class="filename">SConscript</code> files
    created its own construction environment
    by calling <code class="function">Environment</code> separately.
    This obviously works fine,
    but if each program must be built
    with the same construction variables,
    it's cumbersome and error-prone to initialize
    separate construction environments
    in the same way over and over in each subsidiary
    <code class="filename">SConscript</code> file.

    </p><p>

    <span class="application">SCons</span> supports the ability to <span class="emphasis"><em>export</em></span> variables
    from a parent <code class="filename">SConscript</code> file
    to its subsidiary <code class="filename">SConscript</code> files,
    which allows you to share common initialized
    values throughout your build hierarchy.

    </p><div class="section" title="14.5.1. Exporting Variables"><div class="titlepage"><div><div><h3 class="title"><a name="idm3318"></a>14.5.1. Exporting Variables</h3></div></div></div><p>

      There are two ways to export a variable,
      such as a construction environment,
      from an <code class="filename">SConscript</code> file,
      so that it may be used by other <code class="filename">SConscript</code> files.
      First, you can call the <code class="function">Export</code>
      function with a list of variables,
      or a string of white-space separated variable names.
      Each call to <code class="function">Export</code> adds one
      or more variables to a global list
      of variables that are available for import
      by other <code class="filename">SConscript</code> files.

      </p><pre class="programlisting">
env = Environment()
Export('env')
      </pre><p>

      You may export more than one variable name at a time:

      </p><pre class="programlisting">
env = Environment()
debug = ARGUMENTS['debug']
Export('env', 'debug')
      </pre><p>

      Because white space is not legal in Python variable names,
      the <code class="function">Export</code> function will even automatically split
      a string into separate names for you:

      </p><pre class="programlisting">
Export('env debug')
      </pre><p>

      Second, you can specify a list of
      variables to export as a second argument
      to the <code class="filename">SConscript</code> function call:

      </p><pre class="programlisting">
SConscript('src/SConscript', 'env')
      </pre><p>

      Or as the <code class="varname">exports</code> keyword argument:

      </p><pre class="programlisting">
SConscript('src/SConscript', exports='env')
      </pre><p>

      These calls export the specified variables
      to only the listed <code class="filename">SConscript</code> files.
      You may, however, specify more than one
      <code class="filename">SConscript</code> file in a list:

      </p><pre class="programlisting">
SConscript(['src1/SConscript',
            'src2/SConscript'], exports='env')
      </pre><p>

      This is functionally equivalent to
      calling the <code class="filename">SConscript</code> function
      multiple times with the same <code class="varname">exports</code> argument,
      one per <code class="filename">SConscript</code> file.

      </p></div><div class="section" title="14.5.2. Importing Variables"><div class="titlepage"><div><div><h3 class="title"><a name="idm3346"></a>14.5.2. Importing Variables</h3></div></div></div><p>

      Once a variable has been exported from a calling
      <code class="filename">SConscript</code> file,
      it may be used in other <code class="filename">SConscript</code> files
      by calling the <code class="function">Import</code> function:

      </p><pre class="programlisting">
Import('env')
env.Program('prog', ['prog.c'])
      </pre><p>

      The <code class="function">Import</code> call makes the <code class="literal">env</code> construction
      environment available to the <code class="filename">SConscript</code> file,
      after which the variable can be used to build
      programs, libraries, etc.

      </p><p>

      Like the <code class="function">Export</code> function,
      the <code class="function">Import</code> function can be used
      with multiple variable names:

      </p><pre class="programlisting">
Import('env', 'debug')
env = env.Clone(DEBUG = debug)
env.Program('prog', ['prog.c'])
      </pre><p>

      And the <code class="function">Import</code> function will similarly
      split a string along white-space
      into separate variable names:

      </p><pre class="programlisting">
Import('env debug')
env = env.Clone(DEBUG = debug)
env.Program('prog', ['prog.c'])
      </pre><p>

      Lastly, as a special case,
      you may import all of the variables that
      have been exported by supplying an asterisk
      to the <code class="function">Import</code> function:

      </p><pre class="programlisting">
Import('*')
env = env.Clone(DEBUG = debug)
env.Program('prog', ['prog.c'])
      </pre><p>

      If you're dealing with a lot of <code class="filename">SConscript</code> files,
      this can be a lot simpler than keeping
      arbitrary lists of imported variables in each file.

      </p></div><div class="section" title="14.5.3. Returning Values From an SConscript File"><div class="titlepage"><div><div><h3 class="title"><a name="idm3369"></a>14.5.3. Returning Values From an <code class="filename">SConscript</code> File</h3></div></div></div><p>

      Sometimes, you would like to be able to
      use information from a subsidiary
      <code class="filename">SConscript</code> file in some way.
      For example,
      suppose that you want to create one
      library from source files
      scattered throughout a number
      of subsidiary <code class="filename">SConscript</code> files.
      You can do this by using the <code class="function">Return</code>
      function to return values
      from the subsidiary <code class="filename">SConscript</code> files
      to the calling file.

      </p><p>

      If, for example, we have two subdirectories
      <code class="filename">foo</code> and <code class="filename">bar</code>
      that should each contribute a source
      file to a Library,
      what we'd like to be able to do is
      collect the object files
      from the subsidiary <code class="filename">SConscript</code> calls
      like this:

      </p><pre class="programlisting">
env = Environment()
Export('env')
objs = []
for subdir in ['foo', 'bar']:
    o = SConscript('%s/SConscript' % subdir)
    objs.append(o)
env.Library('prog', objs)
        </pre><p>

      We can do this by using the <code class="function">Return</code>
      function in the
      <code class="literal">foo/SConscript</code> file like this:

      </p><pre class="programlisting">
Import('env')
obj = env.Object('foo.c')
Return('obj')
        
</pre><p>

      (The corresponding
      <code class="literal">bar/SConscript</code>
      file should be pretty obvious.)
      Then when we run <span class="application">SCons</span>,
      the object files from the subsidiary subdirectories
      are all correctly archived in the desired library:

      </p><pre class="screen">% <strong class="userinput"><code>scons -Q</code></strong>
cc -o bar/bar.o -c bar/bar.c
cc -o foo/foo.o -c foo/foo.c
ar rc libprog.a foo/foo.o bar/bar.o
ranlib libprog.a
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch14s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch14.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch15.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">14.4. Absolute Path Names </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 15. Separating Source and Build Directories</td></tr></table></div></body></html>
